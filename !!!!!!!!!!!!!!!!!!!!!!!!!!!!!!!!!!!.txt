#!/bin/bash

# Скрипт инициализации базы данных
echo "Инициализация базы данных..."

# Ожидание запуска MySQL
until mysql -h 127.0.0.1 -P 3306 -u root -ppassword -e "SELECT 1" > /dev/null 2>&1; do
    echo "Ожидание запуска MySQL..."
    sleep 2
done

# Создание базы данных и пользователя
mysql -h 127.0.0.1 -P 3306 -u root -ppassword << EOF
CREATE DATABASE IF NOT EXISTS online_store;
CREATE USER IF NOT EXISTS 'app_user'@'%' IDENTIFIED BY 'app_password';
GRANT ALL PRIVILEGES ON online_store.* TO 'app_user'@'%';
FLUSH PRIVILEGES;
EOF

echo "База данных инициализирована успешно"

#!/bin/bash

# Скрипт для запуска тестов
echo "Запуск тестов E-commerce приложения..."

# Проверка наличия Maven
if ! command -v mvn &> /dev/null; then
    echo "Ошибка: Maven не установлен"
    exit 1
fi

# Запуск тестов
echo "Запуск unit тестов..."
mvn test

if [ $? -eq 0 ]; then
    echo "Unit тесты прошли успешно"
else
    echo "Unit тесты завершились с ошибками"
    exit 1
fi

echo "Запуск интеграционных тестов..."
mvn verify -DskipUnitTests=false

if [ $? -eq 0 ]; then
    echo "Все тесты прошли успешно!"
else
    echo "Интеграционные тесты завершились с ошибками"
    exit 1
fi

# Генерация отчета о покрытии
echo "Генерация отчета о покрытии..."
mvn jacoco:report

echo "Отчет о покрытии доступен в target/site/jacoco/index.html"

#!/bin/bash

# Скрипт для запуска MySQL в Docker
echo "Запуск MySQL в Docker..."

docker run --name ecommerce-mysql \
  -e MYSQL_ROOT_PASSWORD=password \
  -e MYSQL_DATABASE=online_store \
  -e MYSQL_USER=app_user \
  -e MYSQL_PASSWORD=app_password \
  -p 3306:3306 \
  -d mysql:8.0 \
  --default-authentication-plugin=mysql_native_password

echo "MySQL запущен на порту 3306"
echo "Подключение: mysql -h 127.0.0.1 -P 3306 -u root -p"

package com.ecommerce.onlinestore.config;

import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

import javax.sql.DataSource;

@Configuration
@EnableJpaAuditing
public class DatabaseConfig {

    // Базовая конфигурация через application.yml
    // Дополнительные настройки можно добавить здесь

    /*
    @Bean
    public DataSource dataSource() {
        return DataSourceBuilder.create()
                .url("jdbc:mysql://localhost:3306/online_store")
                .username("root")
                .password("password")
                .driverClassName("com.mysql.cj.jdbc.Driver")
                .build();
    }
    */
}

package com.ecommerce.onlinestore.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.Contact;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("E-commerce API")
                        .version("1.0")
                        .description("Backend API for Online Store")
                        .contact(new Contact()
                                .name("Development Team")
                                .email("dev@example.com")));
    }
}

package com.ecommerce.onlinestore.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins("http://localhost:3000")
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true);
    }
}

package com.ecommerce.onlinestore.controller;

import com.ecommerce.onlinestore.model.dto.AddToCartRequest;
import com.ecommerce.onlinestore.model.dto.CartDTO;
import com.ecommerce.onlinestore.model.dto.UpdateCartItemRequest;
import com.ecommerce.onlinestore.service.CartService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

@RestController
@RequestMapping("/api/carts")
@RequiredArgsConstructor
@Tag(name = "Cart Management", description = "APIs for managing shopping carts")
public class CartController {

    private final CartService cartService;

    @PostMapping
    @Operation(summary = "Create cart", description = "Create a new shopping cart")
    public ResponseEntity<CartDTO> createCart(@RequestParam(required = false) String sessionId) {
        String cartSessionId = sessionId != null ? sessionId : generateSessionId();
        CartDTO cart = cartService.createCart(cartSessionId);
        return ResponseEntity.ok(cart);
    }

    @GetMapping("/{cartId}")
    @Operation(summary = "Get cart", description = "Retrieve cart by ID")
    public ResponseEntity<CartDTO> getCart(@PathVariable Long cartId) {
        CartDTO cart = cartService.getCartById(cartId);
        return ResponseEntity.ok(cart);
    }

    @GetMapping("/session/{sessionId}")
    @Operation(summary = "Get cart by session", description = "Retrieve cart by session ID")
    public ResponseEntity<CartDTO> getCartBySession(@PathVariable String sessionId) {
        CartDTO cart = cartService.getCartBySessionId(sessionId);
        return ResponseEntity.ok(cart);
    }

    @PostMapping("/{cartId}/items")
    @Operation(summary = "Add item to cart", description = "Add product to shopping cart")
    public ResponseEntity<CartDTO> addItemToCart(
            @PathVariable Long cartId,
            @Valid @RequestBody AddToCartRequest request) {

        CartDTO cart = cartService.addItemToCart(cartId, request);
        return ResponseEntity.ok(cart);
    }

    @PutMapping("/{cartId}/items/{itemId}")
    @Operation(summary = "Update cart item", description = "Update quantity of item in cart")
    public ResponseEntity<CartDTO> updateCartItem(
            @PathVariable Long cartId,
            @PathVariable Long itemId,
            @Valid @RequestBody UpdateCartItemRequest request) {

        CartDTO cart = cartService.updateCartItem(cartId, itemId, request);
        return ResponseEntity.ok(cart);
    }

    @DeleteMapping("/{cartId}/items/{itemId}")
    @Operation(summary = "Remove item from cart", description = "Remove item from shopping cart")
    public ResponseEntity<CartDTO> removeItemFromCart(
            @PathVariable Long cartId,
            @PathVariable Long itemId) {

        CartDTO cart = cartService.removeItemFromCart(cartId, itemId);
        return ResponseEntity.ok(cart);
    }

    @DeleteMapping("/{cartId}/clear")
    @Operation(summary = "Clear cart", description = "Remove all items from cart")
    public ResponseEntity<Void> clearCart(@PathVariable Long cartId) {
        cartService.clearCart(cartId);
        return ResponseEntity.ok().build();
    }

    @DeleteMapping("/{cartId}")
    @Operation(summary = "Delete cart", description = "Delete shopping cart")
    public ResponseEntity<Void> deleteCart(@PathVariable Long cartId) {
        cartService.deleteCart(cartId);
        return ResponseEntity.ok().build();
    }

    @PostMapping("/merge")
    @Operation(summary = "Merge carts", description = "Merge two shopping carts")
    public ResponseEntity<CartDTO> mergeCarts(
            @RequestParam Long sourceCartId,
            @RequestParam Long targetCartId) {

        CartDTO mergedCart = cartService.mergeCarts(sourceCartId, targetCartId);
        return ResponseEntity.ok(mergedCart);
    }

    private String generateSessionId() {
        return "session-" + UUID.randomUUID().toString();
    }
}

package com.ecommerce.onlinestore.controller;

import com.ecommerce.onlinestore.model.exception.BusinessException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException ex) {
        log.warn("Business exception: {}", ex.getMessage());

        ErrorResponse errorResponse = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.BAD_REQUEST.value())
                .error("Business Error")
                .message(ex.getMessage())
                .build();

        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        log.warn("Validation exception: {}", ex.getMessage());

        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });

        ErrorResponse errorResponse = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.BAD_REQUEST.value())
                .error("Validation Error")
                .message("Invalid input parameters")
                .details(errors)
                .build();

        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        log.error("Unexpected error: ", ex);

        ErrorResponse errorResponse = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
                .error("Internal Server Error")
                .message("An unexpected error occurred")
                .build();

        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @lombok.Builder
    @lombok.Data
    private static class ErrorResponse {
        private LocalDateTime timestamp;
        private int status;
        private String error;
        private String message;
        private Map<String, String> details;
    }
}

package com.ecommerce.onlinestore.controller;

import com.ecommerce.onlinestore.model.dto.CreateOrderRequest;
import com.ecommerce.onlinestore.model.dto.OrderDTO;
import com.ecommerce.onlinestore.model.enums.OrderStatus;
import com.ecommerce.onlinestore.service.OrderService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/orders")
@RequiredArgsConstructor
@Tag(name = "Order Management", description = "APIs for managing orders")
public class OrderController {

    private final OrderService orderService;

    @PostMapping
    @Operation(summary = "Create order", description = "Create a new order from cart")
    public ResponseEntity<OrderDTO> createOrder(@Valid @RequestBody CreateOrderRequest request) {
        OrderDTO order = orderService.createOrder(request);
        return ResponseEntity.ok(order);
    }

    @GetMapping
    @Operation(summary = "Get all orders", description = "Retrieve paginated list of all orders")
    public ResponseEntity<Page<OrderDTO>> getAllOrders(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {

        Pageable pageable = PageRequest.of(page, size);
        Page<OrderDTO> orders = orderService.getAllOrders(pageable);
        return ResponseEntity.ok(orders);
    }

    @GetMapping("/{orderId}")
    @Operation(summary = "Get order by ID", description = "Retrieve order by ID")
    public ResponseEntity<OrderDTO> getOrderById(@PathVariable Long orderId) {
        OrderDTO order = orderService.getOrderById(orderId);
        return ResponseEntity.ok(order);
    }

    @GetMapping("/number/{orderNumber}")
    @Operation(summary = "Get order by number", description = "Retrieve order by order number")
    public ResponseEntity<OrderDTO> getOrderByNumber(@PathVariable String orderNumber) {
        OrderDTO order = orderService.getOrderByNumber(orderNumber);
        return ResponseEntity.ok(order);
    }

    @GetMapping("/status/{status}")
    @Operation(summary = "Get orders by status", description = "Retrieve orders by status")
    public ResponseEntity<Page<OrderDTO>> getOrdersByStatus(
            @PathVariable OrderStatus status,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {

        Pageable pageable = PageRequest.of(page, size);
        Page<OrderDTO> orders = orderService.getOrdersByStatus(status, pageable);
        return ResponseEntity.ok(orders);
    }

    @GetMapping("/customer/{email}")
    @Operation(summary = "Get orders by customer", description = "Retrieve orders by customer email")
    public ResponseEntity<Page<OrderDTO>> getOrdersByCustomer(
            @PathVariable String email,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {

        Pageable pageable = PageRequest.of(page, size);
        Page<OrderDTO> orders = orderService.getOrdersByCustomerEmail(email, pageable);
        return ResponseEntity.ok(orders);
    }

    @PutMapping("/{orderId}/status")
    @Operation(summary = "Update order status", description = "Update order status")
    public ResponseEntity<OrderDTO> updateOrderStatus(
            @PathVariable Long orderId,
            @RequestParam OrderStatus status) {

        OrderDTO order = orderService.updateOrderStatus(orderId, status);
        return ResponseEntity.ok(order);
    }

    @PutMapping("/{orderId}/cancel")
    @Operation(summary = "Cancel order", description = "Cancel order")
    public ResponseEntity<OrderDTO> cancelOrder(@PathVariable Long orderId) {
        OrderDTO order = orderService.cancelOrder(orderId);
        return ResponseEntity.ok(order);
    }

    @DeleteMapping("/{orderId}")
    @Operation(summary = "Delete order", description = "Delete order")
    public ResponseEntity<Void> deleteOrder(@PathVariable Long orderId) {
        orderService.deleteOrder(orderId);
        return ResponseEntity.ok().build();
    }
}

package com.ecommerce.onlinestore.controller;

import com.ecommerce.onlinestore.model.dto.ProductDTO;
import com.ecommerce.onlinestore.service.ProductService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;

@RestController
@RequestMapping("/api/products")
@RequiredArgsConstructor
@Tag(name = "Product Management", description = "APIs for managing products")
public class ProductController {

    private final ProductService productService;

    @GetMapping
    @Operation(summary = "Get all products", description = "Retrieve a paginated list of all products")
    public ResponseEntity<Page<ProductDTO>> getAllProducts(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "name") String sortBy,
            @RequestParam(defaultValue = "asc") String direction) {

        Sort sort = direction.equalsIgnoreCase("desc")
                ? Sort.by(sortBy).descending()
                : Sort.by(sortBy).ascending();

        Pageable pageable = PageRequest.of(page, size, sort);
        Page<ProductDTO> products = productService.getAllProducts(pageable);
        return ResponseEntity.ok(products);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Get product by ID", description = "Retrieve a product by its ID")
    public ResponseEntity<ProductDTO> getProductById(@PathVariable Long id) {
        ProductDTO product = productService.getProductById(id);
        return ResponseEntity.ok(product);
    }

    @GetMapping("/sku/{sku}")
    @Operation(summary = "Get product by SKU", description = "Retrieve a product by its SKU")
    public ResponseEntity<ProductDTO> getProductBySku(@PathVariable String sku) {
        ProductDTO product = productService.getProductBySku(sku);
        return ResponseEntity.ok(product);
    }

    @GetMapping("/category/{category}")
    @Operation(summary = "Get products by category", description = "Retrieve products by category")
    public ResponseEntity<Page<ProductDTO>> getProductsByCategory(
            @PathVariable String category,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {

        Pageable pageable = PageRequest.of(page, size);
        Page<ProductDTO> products = productService.getProductsByCategory(category, pageable);
        return ResponseEntity.ok(products);
    }

    @GetMapping("/search")
    @Operation(summary = "Search products", description = "Search products by name")
    public ResponseEntity<Page<ProductDTO>> searchProducts(
            @RequestParam String name,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {

        Pageable pageable = PageRequest.of(page, size);
        Page<ProductDTO> products = productService.searchProducts(name, pageable);
        return ResponseEntity.ok(products);
    }

    @GetMapping("/search/keyword")
    @Operation(summary = "Search products by keyword", description = "Search products by keyword in name or description")
    public ResponseEntity<Page<ProductDTO>> searchByKeyword(
            @RequestParam String keyword,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {

        Pageable pageable = PageRequest.of(page, size);
        Page<ProductDTO> products = productService.searchByKeyword(keyword, pageable);
        return ResponseEntity.ok(products);
    }

    @GetMapping("/filter/price")
    @Operation(summary = "Filter products by price range", description = "Filter products by price range")
    public ResponseEntity<Page<ProductDTO>> getProductsByPriceRange(
            @RequestParam BigDecimal minPrice,
            @RequestParam BigDecimal maxPrice,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {

        Pageable pageable = PageRequest.of(page, size);
        Page<ProductDTO> products = productService.getProductsByPriceRange(minPrice, maxPrice, pageable);
        return ResponseEntity.ok(products);
    }

    @GetMapping("/filter/category-price")
    @Operation(summary = "Filter products by category and price", description = "Filter products by category and price range")
    public ResponseEntity<Page<ProductDTO>> getProductsByCategoryAndPriceRange(
            @RequestParam String category,
            @RequestParam BigDecimal minPrice,
            @RequestParam BigDecimal maxPrice,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {

        Pageable pageable = PageRequest.of(page, size);
        Page<ProductDTO> products = productService.getProductsByCategoryAndPriceRange(
                category, minPrice, maxPrice, pageable);
        return ResponseEntity.ok(products);
    }

    @GetMapping("/available")
    @Operation(summary = "Get available products", description = "Get products that are in stock")
    public ResponseEntity<Page<ProductDTO>> getAvailableProducts(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {

        Pageable pageable = PageRequest.of(page, size);
        Page<ProductDTO> products = productService.getAvailableProducts(pageable);
        return ResponseEntity.ok(products);
    }
}

package com.ecommerce.onlinestore.mapper;

import com.ecommerce.onlinestore.model.dto.CartDTO;
import com.ecommerce.onlinestore.model.dto.CartItemDTO;
import com.ecommerce.onlinestore.model.entity.Cart;
import com.ecommerce.onlinestore.model.entity.CartItem;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring", uses = {ProductMapper.class})
public interface CartMapper {

    CartDTO toDTO(Cart cart);

    @Mapping(source = "product.id", target = "productId")
    @Mapping(source = "product.name", target = "productName")
    @Mapping(source = "product.price", target = "productPrice")
    @Mapping(source = "unitPrice", target = "unitPrice")
    @Mapping(expression = "java(item.getUnitPrice().multiply(java.math.BigDecimal.valueOf(item.getQuantity())))",
            target = "totalPrice")
    CartItemDTO itemToDTO(CartItem item);
}

package com.ecommerce.onlinestore.mapper;

import com.ecommerce.onlinestore.model.dto.*;
import com.ecommerce.onlinestore.model.entity.Order;
import com.ecommerce.onlinestore.model.entity.OrderItem;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface OrderMapper {

    OrderDTO toDTO(Order order);

    CustomerInfoDTO toCustomerInfoDTO(com.ecommerce.onlinestore.model.entity.CustomerInfo customerInfo);

    AddressDTO toAddressDTO(com.ecommerce.onlinestore.model.entity.Address address);

    @Mapping(source = "productId", target = "productId")
    @Mapping(source = "productName", target = "productName")
    @Mapping(source = "unitPrice", target = "unitPrice")
    @Mapping(source = "quantity", target = "quantity")
    @Mapping(source = "totalPrice", target = "totalPrice")
    OrderItemDTO itemToDTO(OrderItem item);

    com.ecommerce.onlinestore.model.entity.CustomerInfo toCustomerInfoEntity(CustomerInfoDTO customerInfoDTO);

    com.ecommerce.onlinestore.model.entity.Address toAddressEntity(AddressDTO addressDTO);
}

package com.ecommerce.onlinestore.mapper;

import com.ecommerce.onlinestore.model.dto.ProductDTO;
import com.ecommerce.onlinestore.model.entity.Product;
import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

@Mapper(componentModel = "spring")
public interface ProductMapper {

    ProductMapper INSTANCE = Mappers.getMapper(ProductMapper.class);

    ProductDTO toDTO(Product product);

    Product toEntity(ProductDTO productDTO);
}

package com.ecommerce.onlinestore.model.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AddressDTO {
    private String street;
    private String city;
    private String state;
    private String postalCode;
    private String country;
}

package com.ecommerce.onlinestore.model.dto;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class AddToCartRequest {

    @NotNull(message = "Product ID is required")
    private Long productId;

    @NotNull(message = "Quantity is required")
    @Positive(message = "Quantity must be positive")
    private Integer quantity;
}

package com.ecommerce.onlinestore.model.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CartDTO {
    private Long id;
    private String sessionId;

    @Builder.Default
    private List<CartItemDTO> items = new ArrayList<>();

    private BigDecimal totalPrice;
    private Integer totalItems;
}

package com.ecommerce.onlinestore.model.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CartItemDTO {
    private Long id;
    private Long productId;
    private String productName;
    private BigDecimal productPrice;
    private Integer quantity;
    private BigDecimal unitPrice;
    private BigDecimal totalPrice;
}

package com.ecommerce.onlinestore.model.dto;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateOrderRequest {

    @NotNull(message = "Cart ID is required")
    private Long cartId;

    @Valid
    @NotNull(message = "Customer info is required")
    private CustomerInfoDTO customerInfo;

    @Valid
    @NotNull(message = "Shipping address is required")
    private AddressDTO shippingAddress;
}

package com.ecommerce.onlinestore.model.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CustomerInfoDTO {
    private String customerName;
    private String customerEmail;
    private String customerPhone;
}

package com.ecommerce.onlinestore.model.dto;

import com.ecommerce.onlinestore.model.enums.OrderStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderDTO {
    private Long id;
    private String orderNumber;
    private OrderStatus status;
    private BigDecimal totalAmount;

    @Builder.Default
    private List<OrderItemDTO> orderItems = new ArrayList<>();

    private CustomerInfoDTO customerInfo;
    private AddressDTO shippingAddress;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}

package com.ecommerce.onlinestore.model.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderItemDTO {
    private Long id;
    private Long productId;
    private String productName;
    private BigDecimal unitPrice;
    private Integer quantity;
    private BigDecimal totalPrice;
}

package com.ecommerce.onlinestore.model.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ProductDTO {
    private Long id;
    private String name;
    private String description;
    private BigDecimal price;
    private Integer stockQuantity;
    private String category;
    private String imageUrl;
    private String sku;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}

package com.ecommerce.onlinestore.model.dto;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UpdateCartItemRequest {

    @NotNull(message = "Quantity is required")
    @Positive(message = "Quantity must be positive")
    private Integer quantity;
}

package com.ecommerce.onlinestore.model.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.*;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Address {

    @Column(name = "street", nullable = false, length = 255)
    private String street;

    @Column(name = "city", nullable = false, length = 100)
    private String city;

    @Column(name = "state", length = 100)
    private String state;

    @Column(name = "postal_code", nullable = false, length = 20)
    private String postalCode;

    @Column(name = "country", nullable = false, length = 100)
    private String country;
}

package com.ecommerce.onlinestore.model.entity;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "carts")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Cart {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "session_id", unique = true, length = 255)
    private String sessionId;

    @OneToMany(mappedBy = "cart", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    private List<CartItem> items = new ArrayList<>();

    @Column(name = "total_price", precision = 10, scale = 2)
    @Builder.Default
    private BigDecimal totalPrice = BigDecimal.ZERO;

    @Column(name = "total_items")
    @Builder.Default
    private Integer totalItems = 0;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
        calculateTotals();
    }

    public void calculateTotals() {
        this.totalItems = items.stream()
                .mapToInt(CartItem::getQuantity)
                .sum();

        this.totalPrice = items.stream()
                .map(item -> item.getProduct().getPrice().multiply(BigDecimal.valueOf(item.getQuantity())))
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    public void addItem(CartItem item) {
        items.add(item);
        item.setCart(this);
        calculateTotals();
    }

    public void removeItem(CartItem item) {
        items.remove(item);
        item.setCart(null);
        calculateTotals();
    }

    public void clear() {
        items.clear();
        calculateTotals();
    }
}

package com.ecommerce.onlinestore.model.entity;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;

@Entity
@Table(name = "cart_items")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CartItem {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "cart_id", nullable = false)
    private Cart cart;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;

    @Column(nullable = false)
    private Integer quantity;

    @Column(name = "unit_price", precision = 10, scale = 2)
    private BigDecimal unitPrice;

    @PrePersist
    @PreUpdate
    protected void onSave() {
        if (product != null && unitPrice == null) {
            unitPrice = product.getPrice();
        }
    }
}

package com.ecommerce.onlinestore.model.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.*;

@Embeddable
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CustomerInfo {

    @Column(name = "customer_name", nullable = false, length = 255)
    private String customerName;

    @Column(name = "customer_email", nullable = false, length = 255)
    private String customerEmail;

    @Column(name = "customer_phone", length = 50)
    private String customerPhone;
}

package com.ecommerce.onlinestore.model.entity;

import com.ecommerce.onlinestore.model.enums.OrderStatus;
import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "orders")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "order_number", unique = true, nullable = false, length = 50)
    private String orderNumber;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    @Builder.Default
    private OrderStatus status = OrderStatus.PENDING;

    @Column(name = "total_amount", nullable = false, precision = 10, scale = 2)
    private BigDecimal totalAmount;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    private List<OrderItem> orderItems = new ArrayList<>();

    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = "customerName", column = @Column(name = "customer_name")),
            @AttributeOverride(name = "customerEmail", column = @Column(name = "customer_email")),
            @AttributeOverride(name = "customerPhone", column = @Column(name = "customer_phone"))
    })
    private CustomerInfo customerInfo;

    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = "street", column = @Column(name = "shipping_street")),
            @AttributeOverride(name = "city", column = @Column(name = "shipping_city")),
            @AttributeOverride(name = "state", column = @Column(name = "shipping_state")),
            @AttributeOverride(name = "postalCode", column = @Column(name = "shipping_postal_code")),
            @AttributeOverride(name = "country", column = @Column(name = "shipping_country"))
    })
    private Address shippingAddress;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
        if (orderNumber == null) {
            orderNumber = "ORD-" + System.currentTimeMillis();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    public void addOrderItem(OrderItem item) {
        orderItems.add(item);
        item.setOrder(this);
    }

    public void calculateTotalAmount() {
        this.totalAmount = orderItems.stream()
                .map(item -> item.getUnitPrice().multiply(BigDecimal.valueOf(item.getQuantity())))
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
}

package com.ecommerce.onlinestore.model.entity;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;

@Entity
@Table(name = "order_items")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OrderItem {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;

    @Column(name = "product_id", nullable = false)
    private Long productId;

    @Column(name = "product_name", nullable = false, length = 255)
    private String productName;

    @Column(name = "unit_price", nullable = false, precision = 10, scale = 2)
    private BigDecimal unitPrice;

    @Column(nullable = false)
    private Integer quantity;

    @Column(name = "total_price", nullable = false, precision = 10, scale = 2)
    private BigDecimal totalPrice;

    @PrePersist
    @PreUpdate
    public void calculateTotalPrice() {
        if (unitPrice != null && quantity != null) {
            this.totalPrice = unitPrice.multiply(BigDecimal.valueOf(quantity));
        }
    }
}

package com.ecommerce.onlinestore.model.entity;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "products")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 255)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal price;

    @Column(name = "stock_quantity", nullable = false)
    private Integer stockQuantity;

    @Column(length = 100)
    private String category;

    @Column(name = "image_url")
    private String imageUrl;

    @Column(name = "sku", unique = true, length = 50)
    private String sku;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

package com.ecommerce.onlinestore.model.enums;

public enum OrderStatus {
    PENDING,
    CONFIRMED,
    PROCESSING,
    SHIPPED,
    DELIVERED,
    CANCELLED
}

package com.ecommerce.onlinestore.model.exception;

public class BusinessException extends RuntimeException {

    public BusinessException(String message) {
        super(message);
    }

    public BusinessException(String message, Throwable cause) {
        super(message, cause);
    }
}

package com.ecommerce.onlinestore.model.exception;

public class CartNotFoundException extends BusinessException {

    public CartNotFoundException(Long cartId) {
        super("Cart not found with id: " + cartId);
    }

    public CartNotFoundException(String message) {
        super(message);
    }
}

package com.ecommerce.onlinestore.model.exception;

public class InsufficientStockException extends BusinessException {

    public InsufficientStockException(String productName, Integer requested, Integer available) {
        super(String.format("Insufficient stock for product '%s'. Requested: %d, Available: %d",
                productName, requested, available));
    }

    // Добавляем конструктор для строкового сообщения
    public InsufficientStockException(String message) {
        super(message);
    }
}

package com.ecommerce.onlinestore.model.exception;

public class OrderNotFoundException extends BusinessException {

    public OrderNotFoundException(Long orderId) {
        super("Order not found with id: " + orderId);
    }

    public OrderNotFoundException(String orderNumber) {
        super("Order not found with number: " + orderNumber);
    }
}

package com.ecommerce.onlinestore.model.exception;

public class ProductNotFoundException extends BusinessException {

    public ProductNotFoundException(Long productId) {
        super("Product not found with id: " + productId);
    }

    public ProductNotFoundException(String message) {
        super(message);
    }
}

package com.ecommerce.onlinestore.repository;

import com.ecommerce.onlinestore.model.entity.Cart;
import com.ecommerce.onlinestore.model.entity.CartItem;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface CartItemRepository extends JpaRepository<CartItem, Long> {

    Optional<CartItem> findByCartAndProductId(Cart cart, Long productId);

    List<CartItem> findByCartId(Long cartId);

    @Modifying
    @Query("DELETE FROM CartItem ci WHERE ci.cart.id = :cartId")
    void deleteByCartId(@Param("cartId") Long cartId);

    @Modifying
    @Query("DELETE FROM CartItem ci WHERE ci.cart.id = :cartId AND ci.product.id = :productId")
    void deleteByCartIdAndProductId(@Param("cartId") Long cartId, @Param("productId") Long productId);

    @Query("SELECT ci FROM CartItem ci JOIN FETCH ci.product WHERE ci.cart.id = :cartId")
    List<CartItem> findByCartIdWithProduct(@Param("cartId") Long cartId);

    @Query("SELECT COUNT(ci) FROM CartItem ci WHERE ci.cart.id = :cartId")
    Integer countItemsInCart(@Param("cartId") Long cartId);
}

package com.ecommerce.onlinestore.repository;

import com.ecommerce.onlinestore.model.entity.Cart;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.Optional;

@Repository
public interface CartRepository extends JpaRepository<Cart, Long> {

    Optional<Cart> findBySessionId(String sessionId);

    @Query("SELECT c FROM Cart c LEFT JOIN FETCH c.items i LEFT JOIN FETCH i.product WHERE c.id = :id")
    Optional<Cart> findByIdWithItems(@Param("id") Long id);

    @Query("SELECT c FROM Cart c LEFT JOIN FETCH c.items i LEFT JOIN FETCH i.product WHERE c.sessionId = :sessionId")
    Optional<Cart> findBySessionIdWithItems(@Param("sessionId") String sessionId);

    @Modifying
    @Query("DELETE FROM Cart c WHERE c.updatedAt < :cutoffDate")
    void deleteOldCarts(@Param("cutoffDate") LocalDateTime cutoffDate);

    @Query("SELECT COUNT(c) FROM Cart c WHERE c.updatedAt > :since")
    Long countActiveCarts(@Param("since") LocalDateTime since);
}

package com.ecommerce.onlinestore.repository;

import com.ecommerce.onlinestore.model.entity.OrderItem;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface OrderItemRepository extends JpaRepository<OrderItem, Long> {

    List<OrderItem> findByOrderId(Long orderId);

    @Query("SELECT oi FROM OrderItem oi WHERE oi.productId = :productId")
    List<OrderItem> findByProductId(@Param("productId") Long productId);

    @Query("SELECT oi FROM OrderItem oi JOIN oi.order o WHERE oi.productId = :productId AND o.status = 'DELIVERED'")
    List<OrderItem> findDeliveredByProductId(@Param("productId") Long productId);

    @Query("SELECT SUM(oi.quantity) FROM OrderItem oi WHERE oi.productId = :productId")
    Long getTotalQuantitySoldByProductId(@Param("productId") Long productId);

    @Query("SELECT oi.productId, SUM(oi.quantity) as totalSold FROM OrderItem oi GROUP BY oi.productId ORDER BY totalSold DESC")
    List<Object[]> findTopSellingProducts();
}

package com.ecommerce.onlinestore.repository;

import com.ecommerce.onlinestore.model.entity.Order;
import com.ecommerce.onlinestore.model.enums.OrderStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {

    Optional<Order> findByOrderNumber(String orderNumber);

    Page<Order> findByStatus(OrderStatus status, Pageable pageable);

    Page<Order> findByCustomerInfo_CustomerEmail(String customerEmail, Pageable pageable);

    @Query("SELECT o FROM Order o LEFT JOIN FETCH o.orderItems WHERE o.id = :id")
    Optional<Order> findByIdWithItems(@Param("id") Long id);

    @Query("SELECT o FROM Order o LEFT JOIN FETCH o.orderItems WHERE o.orderNumber = :orderNumber")
    Optional<Order> findByOrderNumberWithItems(@Param("orderNumber") String orderNumber);

    @Query("SELECT o FROM Order o WHERE o.createdAt BETWEEN :startDate AND :endDate")
    Page<Order> findByCreatedAtBetween(@Param("startDate") LocalDateTime startDate,
                                       @Param("endDate") LocalDateTime endDate,
                                       Pageable pageable);

    @Query("SELECT o FROM Order o WHERE o.customerInfo.customerEmail = :email AND o.status = :status")
    Page<Order> findByCustomerEmailAndStatus(@Param("email") String email,
                                             @Param("status") OrderStatus status,
                                             Pageable pageable);

    @Query("SELECT COUNT(o) FROM Order o WHERE o.status = :status")
    Long countByStatus(@Param("status") OrderStatus status);

    @Query("SELECT SUM(o.totalAmount) FROM Order o WHERE o.createdAt BETWEEN :startDate AND :endDate AND o.status = 'DELIVERED'")
    BigDecimal getTotalRevenueInPeriod(@Param("startDate") LocalDateTime startDate,
                                       @Param("endDate") LocalDateTime endDate);

    List<Order> findByStatusIn(List<OrderStatus> statuses);
}

package com.ecommerce.onlinestore.repository;

import com.ecommerce.onlinestore.model.entity.Product;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {

    Page<Product> findByCategory(String category, Pageable pageable);

    Page<Product> findByNameContainingIgnoreCase(String name, Pageable pageable);

    @Query("SELECT p FROM Product p WHERE p.price BETWEEN :minPrice AND :maxPrice")
    Page<Product> findByPriceBetween(@Param("minPrice") BigDecimal minPrice,
                                     @Param("maxPrice") BigDecimal maxPrice,
                                     Pageable pageable);

    @Query("SELECT p FROM Product p WHERE p.category = :category AND p.price BETWEEN :minPrice AND :maxPrice")
    Page<Product> findByCategoryAndPriceBetween(@Param("category") String category,
                                                @Param("minPrice") BigDecimal minPrice,
                                                @Param("maxPrice") BigDecimal maxPrice,
                                                Pageable pageable);

    List<Product> findByStockQuantityGreaterThan(Integer quantity);

    Optional<Product> findBySku(String sku);

    @Query("SELECT p FROM Product p WHERE p.stockQuantity > 0")
    Page<Product> findAvailableProducts(Pageable pageable);

    @Query("SELECT p FROM Product p WHERE LOWER(p.name) LIKE LOWER(CONCAT('%', :keyword, '%')) OR LOWER(p.description) LIKE LOWER(CONCAT('%', :keyword, '%'))")
    Page<Product> searchByKeyword(@Param("keyword") String keyword, Pageable pageable);

    @Query("SELECT p FROM Product p WHERE p.id IN :productIds")
    List<Product> findByIdIn(@Param("productIds") List<Long> productIds);
}

package com.ecommerce.onlinestore.service.impl;

import com.ecommerce.onlinestore.mapper.CartMapper;
import com.ecommerce.onlinestore.model.dto.AddToCartRequest;
import com.ecommerce.onlinestore.model.dto.CartDTO;
import com.ecommerce.onlinestore.model.dto.UpdateCartItemRequest;
import com.ecommerce.onlinestore.model.entity.Cart;
import com.ecommerce.onlinestore.model.entity.CartItem;
import com.ecommerce.onlinestore.model.entity.Product;
import com.ecommerce.onlinestore.model.exception.CartNotFoundException;
import com.ecommerce.onlinestore.model.exception.InsufficientStockException;
import com.ecommerce.onlinestore.model.exception.ProductNotFoundException;
import com.ecommerce.onlinestore.repository.CartRepository;
import com.ecommerce.onlinestore.repository.ProductRepository;
import com.ecommerce.onlinestore.service.CartService;
import com.ecommerce.onlinestore.util.Constants;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional
public class CartServiceImpl implements CartService {

    private final CartRepository cartRepository;
    private final ProductRepository productRepository;
    private final CartMapper cartMapper;

    @Override
    public CartDTO createCart(String sessionId) {
        log.debug("Creating new cart for session: {}", sessionId);

        Cart cart = Cart.builder()
                .sessionId(sessionId)
                .build();

        Cart savedCart = cartRepository.save(cart);
        log.info("Created new cart with id: {} for session: {}", savedCart.getId(), sessionId);

        return cartMapper.toDTO(savedCart);
    }

    @Override
    @Transactional(readOnly = true)
    public CartDTO getCartById(Long cartId) {
        log.debug("Fetching cart by id: {}", cartId);

        Cart cart = cartRepository.findByIdWithItems(cartId)
                .orElseThrow(() -> new CartNotFoundException(cartId));

        return cartMapper.toDTO(cart);
    }

    @Override
    @Transactional(readOnly = true)
    public CartDTO getCartBySessionId(String sessionId) {
        log.debug("Fetching cart by session id: {}", sessionId);

        Cart cart = cartRepository.findBySessionIdWithItems(sessionId)
                .orElseThrow(() -> new CartNotFoundException("Cart not found for session: " + sessionId));

        return cartMapper.toDTO(cart);
    }

    @Override
    public CartDTO addItemToCart(Long cartId, AddToCartRequest request) {
        log.debug("Adding item to cart: {}, product: {}, quantity: {}",
                cartId, request.getProductId(), request.getQuantity());

        Cart cart = cartRepository.findByIdWithItems(cartId)
                .orElseThrow(() -> new CartNotFoundException(cartId));

        Product product = productRepository.findById(request.getProductId())
                .orElseThrow(() -> new ProductNotFoundException(request.getProductId()));

        validateStockAvailability(product, request.getQuantity());

        // Check if item already exists in cart
        CartItem existingItem = cart.getItems().stream()
                .filter(item -> item.getProduct().getId().equals(product.getId()))
                .findFirst()
                .orElse(null);

        if (existingItem != null) {
            // Update existing item quantity
            int newQuantity = existingItem.getQuantity() + request.getQuantity();
            validateMaxQuantity(newQuantity);
            existingItem.setQuantity(newQuantity);
        } else {
            // Create new cart item
            CartItem newItem = CartItem.builder()
                    .cart(cart)
                    .product(product)
                    .quantity(request.getQuantity())
                    .unitPrice(product.getPrice())
                    .build();
            cart.addItem(newItem);
        }

        cart.calculateTotals();
        Cart savedCart = cartRepository.save(cart);
        log.info("Added product {} to cart {}", product.getId(), cartId);

        return cartMapper.toDTO(savedCart);
    }

    @Override
    public CartDTO updateCartItem(Long cartId, Long itemId, UpdateCartItemRequest request) {
        log.debug("Updating cart item: {} in cart: {} with quantity: {}", itemId, cartId, request.getQuantity());

        Cart cart = cartRepository.findByIdWithItems(cartId)
                .orElseThrow(() -> new CartNotFoundException(cartId));

        CartItem cartItem = cart.getItems().stream()
                .filter(item -> item.getId().equals(itemId))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Cart item not found with id: " + itemId));

        validateMaxQuantity(request.getQuantity());
        validateStockAvailability(cartItem.getProduct(), request.getQuantity());

        cartItem.setQuantity(request.getQuantity());
        cart.calculateTotals();

        Cart savedCart = cartRepository.save(cart);
        log.info("Updated cart item {} in cart {} to quantity {}", itemId, cartId, request.getQuantity());

        return cartMapper.toDTO(savedCart);
    }

    @Override
    public CartDTO removeItemFromCart(Long cartId, Long itemId) {
        log.debug("Removing item: {} from cart: {}", itemId, cartId);

        Cart cart = cartRepository.findByIdWithItems(cartId)
                .orElseThrow(() -> new CartNotFoundException(cartId));

        CartItem cartItem = cart.getItems().stream()
                .filter(item -> item.getId().equals(itemId))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Cart item not found with id: " + itemId));

        cart.removeItem(cartItem);
        Cart savedCart = cartRepository.save(cart);
        log.info("Removed cart item {} from cart {}", itemId, cartId);

        return cartMapper.toDTO(savedCart);
    }

    @Override
    public void clearCart(Long cartId) {
        log.debug("Clearing cart: {}", cartId);

        Cart cart = cartRepository.findByIdWithItems(cartId)
                .orElseThrow(() -> new CartNotFoundException(cartId));

        cart.clear();
        cartRepository.save(cart);
        log.info("Cleared cart {}", cartId);
    }

    @Override
    public void deleteCart(Long cartId) {
        log.debug("Deleting cart: {}", cartId);

        if (!cartRepository.existsById(cartId)) {
            throw new CartNotFoundException(cartId);
        }

        cartRepository.deleteById(cartId);
        log.info("Deleted cart {}", cartId);
    }

    @Override
    public CartDTO mergeCarts(Long sourceCartId, Long targetCartId) {
        log.debug("Merging cart {} into cart {}", sourceCartId, targetCartId);

        Cart sourceCart = cartRepository.findByIdWithItems(sourceCartId)
                .orElseThrow(() -> new CartNotFoundException(sourceCartId));

        Cart targetCart = cartRepository.findByIdWithItems(targetCartId)
                .orElseThrow(() -> new CartNotFoundException(targetCartId));

        // Merge items from source cart to target cart
        for (CartItem sourceItem : sourceCart.getItems()) {
            CartItem existingItem = targetCart.getItems().stream()
                    .filter(item -> item.getProduct().getId().equals(sourceItem.getProduct().getId()))
                    .findFirst()
                    .orElse(null);

            if (existingItem != null) {
                int newQuantity = existingItem.getQuantity() + sourceItem.getQuantity();
                validateMaxQuantity(newQuantity);
                validateStockAvailability(sourceItem.getProduct(), newQuantity);
                existingItem.setQuantity(newQuantity);
            } else {
                CartItem newItem = CartItem.builder()
                        .cart(targetCart)
                        .product(sourceItem.getProduct())
                        .quantity(sourceItem.getQuantity())
                        .unitPrice(sourceItem.getUnitPrice())
                        .build();
                targetCart.addItem(newItem);
            }
        }

        targetCart.calculateTotals();
        Cart savedCart = cartRepository.save(targetCart);

        // Delete source cart after merge
        cartRepository.delete(sourceCart);

        log.info("Merged cart {} into cart {}", sourceCartId, targetCartId);
        return cartMapper.toDTO(savedCart);
    }

    private void validateStockAvailability(Product product, Integer requestedQuantity) {
        if (product.getStockQuantity() < requestedQuantity) {
            throw new InsufficientStockException(
                    product.getName(), requestedQuantity, product.getStockQuantity());
        }
    }

    private void validateMaxQuantity(Integer quantity) {
        if (quantity > Constants.MAX_CART_QUANTITY) {
            throw new RuntimeException("Maximum quantity per product is " + Constants.MAX_CART_QUANTITY);
        }
        if (quantity < Constants.MIN_CART_QUANTITY) {
            throw new RuntimeException("Minimum quantity per product is " + Constants.MIN_CART_QUANTITY);
        }
    }
}

package com.ecommerce.onlinestore.service.impl;

import com.ecommerce.onlinestore.mapper.OrderMapper;
import com.ecommerce.onlinestore.model.dto.CreateOrderRequest;
import com.ecommerce.onlinestore.model.dto.OrderDTO;
import com.ecommerce.onlinestore.model.entity.*;
import com.ecommerce.onlinestore.model.enums.OrderStatus;
import com.ecommerce.onlinestore.model.exception.CartNotFoundException;
import com.ecommerce.onlinestore.model.exception.InsufficientStockException;
import com.ecommerce.onlinestore.model.exception.OrderNotFoundException;
import com.ecommerce.onlinestore.model.exception.ProductNotFoundException;
import com.ecommerce.onlinestore.repository.CartRepository;
import com.ecommerce.onlinestore.repository.OrderRepository;
import com.ecommerce.onlinestore.repository.ProductRepository;
import com.ecommerce.onlinestore.service.OrderService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional
public class OrderServiceImpl implements OrderService {

    private final OrderRepository orderRepository;
    private final CartRepository cartRepository;
    private final ProductRepository productRepository;
    private final OrderMapper orderMapper;

    @Override
    public OrderDTO createOrder(CreateOrderRequest request) {
        log.debug("Creating order from cart: {}", request.getCartId());

        // Fetch cart with items
        Cart cart = cartRepository.findByIdWithItems(request.getCartId())
                .orElseThrow(() -> new CartNotFoundException(request.getCartId()));

        // Validate cart is not empty
        if (cart.getItems().isEmpty()) {
            throw new RuntimeException("Cannot create order from empty cart");
        }

        // Validate stock and reserve products
        validateAndReserveStock(cart);

        // Create order
        Order order = buildOrderFromCart(cart, request);

        // Save order
        Order savedOrder = orderRepository.save(order);

        // Update product stock
        updateProductStock(cart);

        // Clear cart after successful order creation
        cart.clear();
        cartRepository.save(cart);

        log.info("Created order {} from cart {}", savedOrder.getOrderNumber(), request.getCartId());
        return orderMapper.toDTO(savedOrder);
    }

    @Override
    @Transactional(readOnly = true)
    public OrderDTO getOrderById(Long orderId) {
        log.debug("Fetching order by id: {}", orderId);

        Order order = orderRepository.findByIdWithItems(orderId)
                .orElseThrow(() -> new OrderNotFoundException(orderId));

        return orderMapper.toDTO(order);
    }

    @Override
    @Transactional(readOnly = true)
    public OrderDTO getOrderByNumber(String orderNumber) {
        log.debug("Fetching order by number: {}", orderNumber);

        Order order = orderRepository.findByOrderNumberWithItems(orderNumber)
                .orElseThrow(() -> new OrderNotFoundException(orderNumber));

        return orderMapper.toDTO(order);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<OrderDTO> getAllOrders(Pageable pageable) {
        log.debug("Fetching all orders with pageable: {}", pageable);
        return orderRepository.findAll(pageable)
                .map(orderMapper::toDTO);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<OrderDTO> getOrdersByStatus(OrderStatus status, Pageable pageable) {
        log.debug("Fetching orders by status: {}", status);
        return orderRepository.findByStatus(status, pageable)
                .map(orderMapper::toDTO);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<OrderDTO> getOrdersByCustomerEmail(String email, Pageable pageable) {
        log.debug("Fetching orders by customer email: {}", email);
        return orderRepository.findByCustomerInfo_CustomerEmail(email, pageable)
                .map(orderMapper::toDTO);
    }

    @Override
    public OrderDTO updateOrderStatus(Long orderId, OrderStatus status) {
        log.debug("Updating order {} status to: {}", orderId, status);

        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new OrderNotFoundException(orderId));

        // Validate status transition
        validateStatusTransition(order.getStatus(), status);

        order.setStatus(status);
        Order savedOrder = orderRepository.save(order);

        log.info("Updated order {} status to {}", orderId, status);
        return orderMapper.toDTO(savedOrder);
    }

    @Override
    public OrderDTO cancelOrder(Long orderId) {
        log.debug("Cancelling order: {}", orderId);

        Order order = orderRepository.findByIdWithItems(orderId)
                .orElseThrow(() -> new OrderNotFoundException(orderId));

        // Only pending or confirmed orders can be cancelled
        if (order.getStatus() != OrderStatus.PENDING && order.getStatus() != OrderStatus.CONFIRMED) {
            throw new RuntimeException("Order cannot be cancelled in current status: " + order.getStatus());
        }

        // Restore product stock
        restoreProductStock(order);

        order.setStatus(OrderStatus.CANCELLED);
        Order savedOrder = orderRepository.save(order);

        log.info("Cancelled order {}", orderId);
        return orderMapper.toDTO(savedOrder);
    }

    @Override
    public void deleteOrder(Long orderId) {
        log.debug("Deleting order: {}", orderId);

        if (!orderRepository.existsById(orderId)) {
            throw new OrderNotFoundException(orderId);
        }

        orderRepository.deleteById(orderId);
        log.info("Deleted order {}", orderId);
    }

    private void validateAndReserveStock(Cart cart) {
        List<String> errors = new ArrayList<>();

        for (CartItem item : cart.getItems()) {
            Product product = item.getProduct();
            if (product.getStockQuantity() < item.getQuantity()) {
                errors.add(String.format(
                        "Insufficient stock for product '%s'. Requested: %d, Available: %d",
                        product.getName(), item.getQuantity(), product.getStockQuantity()
                ));
            }
        }

        if (!errors.isEmpty()) {
            throw new RuntimeException(String.join("; ", errors));
        }
    }

    private void updateProductStock(Cart cart) {
        for (CartItem item : cart.getItems()) {
            Product product = item.getProduct();
            int newStock = product.getStockQuantity() - item.getQuantity();
            product.setStockQuantity(newStock);
            productRepository.save(product);
        }
    }

    private void restoreProductStock(Order order) {
        for (OrderItem item : order.getOrderItems()) {
            Product product = productRepository.findById(item.getProductId())
                    .orElseThrow(() -> new ProductNotFoundException(item.getProductId()));
            int restoredStock = product.getStockQuantity() + item.getQuantity();
            product.setStockQuantity(restoredStock);
            productRepository.save(product);
        }
    }

    private Order buildOrderFromCart(Cart cart, CreateOrderRequest request) {
        Order order = Order.builder()
                .customerInfo(orderMapper.toCustomerInfoEntity(request.getCustomerInfo()))
                .shippingAddress(orderMapper.toAddressEntity(request.getShippingAddress()))
                .status(OrderStatus.PENDING)
                .build();

        // Create order items from cart items
        for (CartItem cartItem : cart.getItems()) {
            OrderItem orderItem = OrderItem.builder()
                    .order(order)
                    .productId(cartItem.getProduct().getId())
                    .productName(cartItem.getProduct().getName())
                    .unitPrice(cartItem.getProduct().getPrice())
                    .quantity(cartItem.getQuantity())
                    .build();
            // Вызываем метод расчета общей цены
            orderItem.calculateTotalPrice();
            order.addOrderItem(orderItem);
        }

        order.calculateTotalAmount();
        return order;
    }

    private void validateStatusTransition(OrderStatus currentStatus, OrderStatus newStatus) {
        // Simple validation - in real application, you might want more complex state machine
        if (currentStatus == OrderStatus.CANCELLED || currentStatus == OrderStatus.DELIVERED) {
            throw new RuntimeException("Cannot change status from " + currentStatus);
        }
    }
}

package com.ecommerce.onlinestore.service.impl;

import com.ecommerce.onlinestore.mapper.ProductMapper;
import com.ecommerce.onlinestore.model.dto.ProductDTO;
import com.ecommerce.onlinestore.model.entity.Product;
import com.ecommerce.onlinestore.model.exception.ProductNotFoundException;
import com.ecommerce.onlinestore.repository.ProductRepository;
import com.ecommerce.onlinestore.service.ProductService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class ProductServiceImpl implements ProductService {

    private final ProductRepository productRepository;
    private final ProductMapper productMapper;

    @Override
    public Page<ProductDTO> getAllProducts(Pageable pageable) {
        log.debug("Fetching all products with pageable: {}", pageable);
        return productRepository.findAll(pageable)
                .map(productMapper::toDTO);
    }

    @Override
    public ProductDTO getProductById(Long id) {
        log.debug("Fetching product by id: {}", id);
        Product product = productRepository.findById(id)
                .orElseThrow(() -> new ProductNotFoundException(id));
        return productMapper.toDTO(product);
    }

    @Override
    public Page<ProductDTO> getProductsByCategory(String category, Pageable pageable) {
        log.debug("Fetching products by category: {}", category);
        return productRepository.findByCategory(category, pageable)
                .map(productMapper::toDTO);
    }

    @Override
    public Page<ProductDTO> searchProducts(String name, Pageable pageable) {
        log.debug("Searching products by name: {}", name);
        return productRepository.findByNameContainingIgnoreCase(name, pageable)
                .map(productMapper::toDTO);
    }

    @Override
    public Page<ProductDTO> getProductsByPriceRange(BigDecimal minPrice, BigDecimal maxPrice, Pageable pageable) {
        log.debug("Fetching products by price range: {} - {}", minPrice, maxPrice);
        return productRepository.findByPriceBetween(minPrice, maxPrice, pageable)
                .map(productMapper::toDTO);
    }

    @Override
    public Page<ProductDTO> getProductsByCategoryAndPriceRange(String category, BigDecimal minPrice,
                                                               BigDecimal maxPrice, Pageable pageable) {
        log.debug("Fetching products by category: {} and price range: {} - {}", category, minPrice, maxPrice);
        return productRepository.findByCategoryAndPriceBetween(category, minPrice, maxPrice, pageable)
                .map(productMapper::toDTO);
    }

    @Override
    public Page<ProductDTO> searchByKeyword(String keyword, Pageable pageable) {
        log.debug("Searching products by keyword: {}", keyword);
        return productRepository.searchByKeyword(keyword, pageable)
                .map(productMapper::toDTO);
    }

    @Override
    public Page<ProductDTO> getAvailableProducts(Pageable pageable) {
        log.debug("Fetching available products (in stock)");
        return productRepository.findAvailableProducts(pageable)
                .map(productMapper::toDTO);
    }

    @Override
    public ProductDTO getProductBySku(String sku) {
        log.debug("Fetching product by SKU: {}", sku);
        Product product = productRepository.findBySku(sku)
                .orElseThrow(() -> new ProductNotFoundException("Product not found with SKU: " + sku));
        return productMapper.toDTO(product);
    }
}

package com.ecommerce.onlinestore.service;

import com.ecommerce.onlinestore.model.dto.AddToCartRequest;
import com.ecommerce.onlinestore.model.dto.CartDTO;
import com.ecommerce.onlinestore.model.dto.UpdateCartItemRequest;

public interface CartService {

    CartDTO createCart(String sessionId);

    CartDTO getCartById(Long cartId);

    CartDTO getCartBySessionId(String sessionId);

    CartDTO addItemToCart(Long cartId, AddToCartRequest request);

    CartDTO updateCartItem(Long cartId, Long itemId, UpdateCartItemRequest request);

    CartDTO removeItemFromCart(Long cartId, Long itemId);

    void clearCart(Long cartId);

    void deleteCart(Long cartId);

    CartDTO mergeCarts(Long sourceCartId, Long targetCartId);
}

package com.ecommerce.onlinestore.service;

import com.ecommerce.onlinestore.model.dto.CreateOrderRequest;
import com.ecommerce.onlinestore.model.dto.OrderDTO;
import com.ecommerce.onlinestore.model.enums.OrderStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

public interface OrderService {

    OrderDTO createOrder(CreateOrderRequest request);

    OrderDTO getOrderById(Long orderId);

    OrderDTO getOrderByNumber(String orderNumber);

    Page<OrderDTO> getAllOrders(Pageable pageable);

    Page<OrderDTO> getOrdersByStatus(OrderStatus status, Pageable pageable);

    Page<OrderDTO> getOrdersByCustomerEmail(String email, Pageable pageable);

    OrderDTO updateOrderStatus(Long orderId, OrderStatus status);

    OrderDTO cancelOrder(Long orderId);

    void deleteOrder(Long orderId);
}

package com.ecommerce.onlinestore.service;

import com.ecommerce.onlinestore.model.dto.ProductDTO;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.math.BigDecimal;

public interface ProductService {

    Page<ProductDTO> getAllProducts(Pageable pageable);

    ProductDTO getProductById(Long id);

    Page<ProductDTO> getProductsByCategory(String category, Pageable pageable);

    Page<ProductDTO> searchProducts(String name, Pageable pageable);

    Page<ProductDTO> getProductsByPriceRange(BigDecimal minPrice, BigDecimal maxPrice, Pageable pageable);

    Page<ProductDTO> getProductsByCategoryAndPriceRange(String category, BigDecimal minPrice,
                                                        BigDecimal maxPrice, Pageable pageable);

    Page<ProductDTO> searchByKeyword(String keyword, Pageable pageable);

    Page<ProductDTO> getAvailableProducts(Pageable pageable);

    ProductDTO getProductBySku(String sku);
}

package com.ecommerce.onlinestore.util;

public class Constants {

    public static final String DEFAULT_PAGE_SIZE = "10";
    public static final String DEFAULT_PAGE_NUMBER = "0";
    public static final String DEFAULT_SORT_BY = "id";
    public static final String DEFAULT_SORT_DIRECTION = "asc";

    public static final int MAX_CART_QUANTITY = 99;
    public static final int MIN_CART_QUANTITY = 1;

    private Constants() {
        // Utility class
    }
}

package com.ecommerce.onlinestore;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class OnlineStoreApplication {

    public static void main(String[] args) {
        SpringApplication.run(OnlineStoreApplication.class, args);
    }
}

CREATE TABLE products (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    price DECIMAL(10,2) NOT NULL,
    stock_quantity INT NOT NULL,
    category VARCHAR(100),
    image_url VARCHAR(500),
    sku VARCHAR(50) UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_category (category),
    INDEX idx_price (price),
    INDEX idx_stock (stock_quantity)
);

CREATE TABLE carts (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    session_id VARCHAR(255) UNIQUE,
    total_price DECIMAL(10,2) DEFAULT 0.00,
    total_items INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_session (session_id)
);

CREATE TABLE cart_items (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    cart_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    quantity INT NOT NULL,
    unit_price DECIMAL(10,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (cart_id) REFERENCES carts(id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(id),
    UNIQUE KEY unique_cart_product (cart_id, product_id),
    INDEX idx_cart_id (cart_id)
);

CREATE TABLE orders (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    order_number VARCHAR(50) UNIQUE NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
    total_amount DECIMAL(10,2) NOT NULL,
    customer_name VARCHAR(255) NOT NULL,
    customer_email VARCHAR(255) NOT NULL,
    customer_phone VARCHAR(50),
    shipping_street VARCHAR(255) NOT NULL,
    shipping_city VARCHAR(100) NOT NULL,
    shipping_state VARCHAR(100),
    shipping_postal_code VARCHAR(20) NOT NULL,
    shipping_country VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_order_number (order_number),
    INDEX idx_customer_email (customer_email),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
);

CREATE TABLE order_items (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    order_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    product_name VARCHAR(255) NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    quantity INT NOT NULL,
    total_price DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE,
    INDEX idx_order_id (order_id),
    INDEX idx_product_id (product_id)
);

-- Sample products
INSERT INTO products (name, description, price, stock_quantity, category, sku) VALUES
('MacBook Pro', 'Powerful laptop for professionals', 1999.99, 10, 'Electronics', 'MBP-13-2023'),
('iPhone 15', 'Latest smartphone with advanced features', 999.99, 15, 'Electronics', 'IPHONE-15-128'),
('Spring Boot Guide', 'Complete guide to Spring Boot development', 29.99, 50, 'Books', 'BOOK-SPRING-001'),
('Wireless Headphones', 'Noise cancelling wireless headphones', 149.99, 20, 'Electronics', 'HEAD-WL-001'),
('Java Programming', 'Learn Java programming from scratch', 39.99, 30, 'Books', 'BOOK-JAVA-001'),
('Gaming Mouse', 'High precision gaming mouse', 79.99, 25, 'Electronics', 'MOUSE-GAMING-001');

-- Очистка таблиц (для тестового окружения)
DELETE FROM order_items;
DELETE FROM orders;
DELETE FROM cart_items;
DELETE FROM carts;
DELETE FROM products;

-- Сброс автоинкремента
ALTER TABLE products AUTO_INCREMENT = 1;
ALTER TABLE carts AUTO_INCREMENT = 1;
ALTER TABLE cart_items AUTO_INCREMENT = 1;
ALTER TABLE orders AUTO_INCREMENT = 1;
ALTER TABLE order_items AUTO_INCREMENT = 1;

-- Вставка тестовых товаров
INSERT INTO products (name, description, price, stock_quantity, category, image_url, sku, created_at, updated_at) VALUES
('MacBook Pro 16"', 'Мощный ноутбук для профессионалов с процессором M2 Pro', 2499.99, 15, 'Electronics', '/images/macbook-pro.jpg', 'MBP-16-2023', NOW(), NOW()),
('iPhone 15 Pro', 'Флагманский смартфон с камерой 48MP', 1199.99, 25, 'Electronics', '/images/iphone15-pro.jpg', 'IPHONE-15-PRO-256', NOW(), NOW()),
('Samsung Galaxy S24', 'Android смартфон с AI функциями', 899.99, 20, 'Electronics', '/images/galaxy-s24.jpg', 'SAMSUNG-S24-256', NOW(), NOW()),
('Dell XPS 13', 'Ультрабук с безрамочным дисплеем', 1299.99, 12, 'Electronics', '/images/dell-xps13.jpg', 'DELL-XPS13-2024', NOW(), NOW()),
('Spring Boot in Action', 'Полное руководство по Spring Boot разработке', 39.99, 50, 'Books', '/images/spring-boot-book.jpg', 'BOOK-SPRING-001', NOW(), NOW()),
('Effective Java', 'Лучшие практики программирования на Java', 49.99, 30, 'Books', '/images/effective-java.jpg', 'BOOK-JAVA-001', NOW(), NOW()),
('Sony WH-1000XM5', 'Беспроводные наушники с шумоподавлением', 349.99, 18, 'Electronics', '/images/sony-headphones.jpg', 'SONY-WH1000XM5', NOW(), NOW()),
('Apple Watch Series 9', 'Умные часы с функцией измерения ЭКГ', 399.99, 22, 'Electronics', '/images/apple-watch.jpg', 'APPLE-WATCH-S9', NOW(), NOW()),
('Clean Code', 'Руководство по написанию чистого кода', 34.99, 40, 'Books', '/images/clean-code.jpg', 'BOOK-CLEAN-CODE', NOW(), NOW()),
('Logitech MX Master 3', 'Эргономичная беспроводная мышь', 99.99, 35, 'Electronics', '/images/logitech-mouse.jpg', 'LOGITECH-MX-MASTER3', NOW(), NOW()),
('iPad Air', 'Планшет с чипом M1 и поддержкой Apple Pencil', 599.99, 16, 'Electronics', '/images/ipad-air.jpg', 'IPAD-AIR-5', NOW(), NOW()),
('Design Patterns', 'Классическая книга о шаблонах проектирования', 44.99, 28, 'Books', '/images/design-patterns.jpg', 'BOOK-DESIGN-PATTERNS', NOW(), NOW());

-- Тестовые корзины
INSERT INTO carts (session_id, total_price, total_items, created_at, updated_at) VALUES
('session-user-123', 0.00, 0, NOW(), NOW()),
('session-user-456', 0.00, 0, NOW(), NOW()),
('session-guest-789', 0.00, 0, NOW(), NOW());

-- Тестовые элементы корзины
INSERT INTO cart_items (cart_id, product_id, quantity, unit_price, created_at) VALUES
(1, 1, 1, 2499.99, NOW()),
(1, 3, 2, 899.99, NOW()),
(2, 5, 1, 39.99, NOW()),
(2, 6, 1, 49.99, NOW()),
(3, 7, 1, 349.99, NOW());

-- Обновление итогов корзин
UPDATE carts SET
total_price = (SELECT SUM(unit_price * quantity) FROM cart_items WHERE cart_id = 1),
total_items = (SELECT SUM(quantity) FROM cart_items WHERE cart_id = 1)
WHERE id = 1;

UPDATE carts SET
total_price = (SELECT SUM(unit_price * quantity) FROM cart_items WHERE cart_id = 2),
total_items = (SELECT SUM(quantity) FROM cart_items WHERE cart_id = 2)
WHERE id = 2;

UPDATE carts SET
total_price = (SELECT SUM(unit_price * quantity) FROM cart_items WHERE cart_id = 3),
total_items = (SELECT SUM(quantity) FROM cart_items WHERE cart_id = 3)
WHERE id = 3;

-- Тестовые заказы
INSERT INTO orders (order_number, status, total_amount, customer_name, customer_email, customer_phone, shipping_street, shipping_city, shipping_state, shipping_postal_code, shipping_country, created_at, updated_at) VALUES
('ORD-20240001', 'DELIVERED', 4299.97, 'Иван Петров', 'ivan.petrov@example.com', '+79161234567', 'ул. Ленина, д. 15', 'Москва', 'Московская область', '101000', 'Россия', NOW() - INTERVAL 5 DAY, NOW() - INTERVAL 1 DAY),
('ORD-20240002', 'PROCESSING', 89.98, 'Мария Сидорова', 'maria.sidorova@example.com', '+79269876543', 'пр. Победы, д. 42', 'Санкт-Петербург', 'Ленинградская область', '190000', 'Россия', NOW() - INTERVAL 2 DAY, NOW()),
('ORD-20240003', 'PENDING', 349.99, 'Алексей Козлов', 'alex.kozlov@example.com', '+79031112233', 'ул. Мира, д. 7', 'Казань', 'Татарстан', '420000', 'Россия', NOW() - INTERVAL 1 DAY, NOW());

-- Элементы заказов
INSERT INTO order_items (order_id, product_id, product_name, unit_price, quantity, total_price, created_at) VALUES
(1, 1, 'MacBook Pro 16"', 2499.99, 1, 2499.99, NOW()),
(1, 3, 'Samsung Galaxy S24', 899.99, 2, 1799.98, NOW()),
(2, 5, 'Spring Boot in Action', 39.99, 1, 39.99, NOW()),
(2, 6, 'Effective Java', 49.99, 1, 49.99, NOW()),
(3, 7, 'Sony WH-1000XM5', 349.99, 1, 349.99, NOW());

spring:
  application:
    name: online-store
  datasource:
    url: jdbc:h2:mem:onlinestore;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    username: sa
    password:
    driver-class-name: org.h2.Driver
  jpa:
    hibernate:
      ddl-auto: create
    properties:
      hibernate:
        show_sql: true
        format_sql: true
  h2:
    console:
      enabled: true
  sql:
    init:
      mode: always

server:
  port: 8080

logging:
  level:
    com.ecommerce.onlinestore: INFO
    org.hibernate.SQL: INFO

springdoc:
  api-docs:
    path: /v3/api-docs
  swagger-ui:
    path: /swagger-ui.html

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/online_store?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true
    username: root
    password: password
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      maximum-pool-size: 15
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 300000
      max-lifetime: 1200000

  jpa:
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQLDialect
        show_sql: true
        format_sql: true
        jdbc:
          batch_size: 25
        order_inserts: true
        order_updates: true
        generate_statistics: true
    open-in-view: false

  sql:
    init:
      mode: never

server:
  port: 8080
  servlet:
    context-path: /

logging:
  level:
    com.ecommerce.onlinestore: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.orm.jdbc.bind: TRACE
    org.springframework.transaction: DEBUG
    org.springframework.jdbc.core: TRACE

springdoc:
  api-docs:
    path: /v3/api-docs
  swagger-ui:
    path: /swagger-ui.html
    operations-sorter: method
    tags-sorter: alpha
    enabled: true

app:
  cart:
    session-timeout-hours: 24
    max-quantity-per-item: 99

spring:
  datasource:
    url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE;MODE=MySQL
    username: sa
    password:
    driver-class-name: org.h2.Driver
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.H2Dialect
        format_sql: false
    defer-datasource-initialization: true
  sql:
    init:
      mode: never

logging:
  level:
    com.ecommerce.onlinestore: WARN
    org.hibernate.SQL: WARN
    org.springframework: WARN

springdoc:
  api-docs:
    enabled: false
  swagger-ui:
    enabled: false

package com.ecommerce.onlinestore.controller;

import com.ecommerce.onlinestore.model.dto.CartDTO;
import com.ecommerce.onlinestore.model.dto.CartItemDTO;
import com.ecommerce.onlinestore.service.CartService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import java.math.BigDecimal;
import java.util.Collections;
import java.util.List;

import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(CartController.class)
class CartControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private CartService cartService;

    @Test
    void shouldCreateCart() throws Exception {
        // Given
        CartDTO cart = CartDTO.builder()
                .id(1L)
                .sessionId("session-123")
                .totalPrice(BigDecimal.ZERO)
                .totalItems(0)
                .items(Collections.emptyList())
                .build();

        when(cartService.createCart(anyString())).thenReturn(cart);

        // When & Then
        mockMvc.perform(post("/api/carts")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value(1))
                .andExpect(jsonPath("$.sessionId").value("session-123"));
    }

    @Test
    void shouldGetCartById() throws Exception {
        // Given
        CartDTO cart = CartDTO.builder()
                .id(1L)
                .sessionId("session-123")
                .totalPrice(BigDecimal.ZERO)
                .totalItems(0)
                .items(Collections.emptyList())
                .build();

        when(cartService.getCartById(1L)).thenReturn(cart);

        // When & Then
        mockMvc.perform(get("/api/carts/1")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value(1));
    }

    @Test
    void shouldAddItemToCart() throws Exception {
        // Given
        CartItemDTO cartItem = CartItemDTO.builder()
                .id(1L)
                .productId(1L)
                .productName("Laptop")
                .productPrice(BigDecimal.valueOf(999.99))
                .quantity(2)
                .unitPrice(BigDecimal.valueOf(999.99))
                .totalPrice(BigDecimal.valueOf(1999.98))
                .build();

        CartDTO cart = CartDTO.builder()
                .id(1L)
                .sessionId("session-123")
                .totalPrice(BigDecimal.valueOf(1999.98))
                .totalItems(2)
                .items(List.of(cartItem))
                .build();

        when(cartService.addItemToCart(eq(1L), any())).thenReturn(cart);

        String addItemRequest = """
            {
                "productId": 1,
                "quantity": 2
            }
            """;

        // When & Then
        mockMvc.perform(post("/api/carts/1/items")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(addItemRequest))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.items[0].productId").value(1))
                .andExpect(jsonPath("$.items[0].quantity").value(2))
                .andExpect(jsonPath("$.totalPrice").value(1999.98));
    }

    @Test
    void shouldUpdateCartItem() throws Exception {
        // Given
        CartItemDTO cartItem = CartItemDTO.builder()
                .id(1L)
                .productId(1L)
                .productName("Laptop")
                .productPrice(BigDecimal.valueOf(999.99))
                .quantity(5)
                .unitPrice(BigDecimal.valueOf(999.99))
                .totalPrice(BigDecimal.valueOf(4999.95))
                .build();

        CartDTO cart = CartDTO.builder()
                .id(1L)
                .sessionId("session-123")
                .totalPrice(BigDecimal.valueOf(4999.95))
                .totalItems(5)
                .items(List.of(cartItem))
                .build();

        when(cartService.updateCartItem(eq(1L), eq(1L), any())).thenReturn(cart);

        String updateRequest = """
            {
                "quantity": 5
            }
            """;

        // When & Then
        mockMvc.perform(put("/api/carts/1/items/1")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(updateRequest))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.items[0].quantity").value(5))
                .andExpect(jsonPath("$.totalPrice").value(4999.95));
    }

    @Test
    void shouldRemoveItemFromCart() throws Exception {
        // Given
        CartDTO cart = CartDTO.builder()
                .id(1L)
                .sessionId("session-123")
                .totalPrice(BigDecimal.ZERO)
                .totalItems(0)
                .items(Collections.emptyList())
                .build();

        when(cartService.removeItemFromCart(1L, 1L)).thenReturn(cart);

        // When & Then
        mockMvc.perform(delete("/api/carts/1/items/1")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.items").isEmpty())
                .andExpect(jsonPath("$.totalPrice").value(0));
    }

    @Test
    void shouldClearCart() throws Exception {
        // When & Then
        mockMvc.perform(delete("/api/carts/1/clear")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk());
    }

    @Test
    void shouldValidateAddToCartRequest() throws Exception {
        String invalidRequest = """
            {
                "productId": null,
                "quantity": 0
            }
            """;

        mockMvc.perform(post("/api/carts/1/items")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(invalidRequest))
                .andExpect(status().isBadRequest());
    }
}

package com.ecommerce.onlinestore.controller;

// Этот класс больше не нужен, можно удалить
// Оставлен для возможного будущего использования
public abstract class ControllerTestBase {
    // Базовые утилиты для тестов могут быть добавлены здесь позже
}

package com.ecommerce.onlinestore.controller;

import com.ecommerce.onlinestore.model.dto.OrderDTO;
import com.ecommerce.onlinestore.model.dto.OrderItemDTO;
import com.ecommerce.onlinestore.model.enums.OrderStatus;
import com.ecommerce.onlinestore.service.OrderService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(OrderController.class)
class OrderControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private OrderService orderService;

    @Test
    void shouldCreateOrder() throws Exception {
        // Given
        OrderItemDTO orderItem = OrderItemDTO.builder()
                .id(1L)
                .productId(1L)
                .productName("Laptop")
                .unitPrice(BigDecimal.valueOf(999.99))
                .quantity(1)
                .totalPrice(BigDecimal.valueOf(999.99))
                .build();

        OrderDTO order = OrderDTO.builder()
                .id(1L)
                .orderNumber("ORD-123")
                .status(OrderStatus.PENDING)
                .totalAmount(BigDecimal.valueOf(999.99))
                .orderItems(List.of(orderItem))
                .customerInfo(com.ecommerce.onlinestore.model.dto.CustomerInfoDTO.builder()
                        .customerName("John Doe")
                        .customerEmail("john@example.com")
                        .customerPhone("+1234567890")
                        .build())
                .shippingAddress(com.ecommerce.onlinestore.model.dto.AddressDTO.builder()
                        .street("123 Main St")
                        .city("New York")
                        .state("NY")
                        .postalCode("10001")
                        .country("USA")
                        .build())
                .createdAt(LocalDateTime.now())
                .updatedAt(LocalDateTime.now())
                .build();

        when(orderService.createOrder(any())).thenReturn(order);

        String createOrderRequest = """
            {
                "cartId": 1,
                "customerInfo": {
                    "customerName": "John Doe",
                    "customerEmail": "john@example.com",
                    "customerPhone": "+1234567890"
                },
                "shippingAddress": {
                    "street": "123 Main St",
                    "city": "New York",
                    "state": "NY",
                    "postalCode": "10001",
                    "country": "USA"
                }
            }
            """;

        // When & Then
        mockMvc.perform(post("/api/orders")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(createOrderRequest))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.orderNumber").value("ORD-123"))
                .andExpect(jsonPath("$.status").value("PENDING"))
                .andExpect(jsonPath("$.totalAmount").value(999.99));
    }

    @Test
    void shouldGetOrderById() throws Exception {
        // Given
        OrderDTO order = OrderDTO.builder()
                .id(1L)
                .orderNumber("ORD-123")
                .status(OrderStatus.PENDING)
                .totalAmount(BigDecimal.valueOf(999.99))
                .build();

        when(orderService.getOrderById(1L)).thenReturn(order);

        // When & Then
        mockMvc.perform(get("/api/orders/1")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value(1))
                .andExpect(jsonPath("$.orderNumber").value("ORD-123"));
    }

    @Test
    void shouldGetAllOrders() throws Exception {
        // Given
        OrderDTO order1 = OrderDTO.builder()
                .id(1L)
                .orderNumber("ORD-123")
                .status(OrderStatus.PENDING)
                .totalAmount(BigDecimal.valueOf(999.99))
                .build();

        OrderDTO order2 = OrderDTO.builder()
                .id(2L)
                .orderNumber("ORD-124")
                .status(OrderStatus.CONFIRMED)
                .totalAmount(BigDecimal.valueOf(499.99))
                .build();

        Page<OrderDTO> orderPage = new PageImpl<>(List.of(order1, order2), PageRequest.of(0, 10), 2);

        when(orderService.getAllOrders(any(PageRequest.class))).thenReturn(orderPage);

        // When & Then
        mockMvc.perform(get("/api/orders")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.content").isArray())
                .andExpect(jsonPath("$.content.length()").value(2))
                .andExpect(jsonPath("$.content[0].orderNumber").value("ORD-123"))
                .andExpect(jsonPath("$.content[1].orderNumber").value("ORD-124"));
    }

    @Test
    void shouldUpdateOrderStatus() throws Exception {
        // Given
        OrderDTO order = OrderDTO.builder()
                .id(1L)
                .orderNumber("ORD-123")
                .status(OrderStatus.CONFIRMED)
                .totalAmount(BigDecimal.valueOf(999.99))
                .build();

        when(orderService.updateOrderStatus(1L, OrderStatus.CONFIRMED)).thenReturn(order);

        // When & Then
        mockMvc.perform(put("/api/orders/1/status")
                        .param("status", "CONFIRMED")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.status").value("CONFIRMED"));
    }

    @Test
    void shouldCancelOrder() throws Exception {
        // Given
        OrderDTO order = OrderDTO.builder()
                .id(1L)
                .orderNumber("ORD-123")
                .status(OrderStatus.CANCELLED)
                .totalAmount(BigDecimal.valueOf(999.99))
                .build();

        when(orderService.cancelOrder(1L)).thenReturn(order);

        // When & Then
        mockMvc.perform(put("/api/orders/1/cancel")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.status").value("CANCELLED"));
    }

    @Test
    void shouldValidateCreateOrderRequest() throws Exception {
        String invalidRequest = """
            {
                "cartId": null,
                "customerInfo": null,
                "shippingAddress": null
            }
            """;

        mockMvc.perform(post("/api/orders")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(invalidRequest))
                .andExpect(status().isBadRequest());
    }
}

package com.ecommerce.onlinestore.controller;

import com.ecommerce.onlinestore.model.dto.ProductDTO;
import com.ecommerce.onlinestore.service.ProductService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import java.math.BigDecimal;
import java.util.List;

import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(ProductController.class)
class ProductControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private ProductService productService;

    @Test
    void shouldGetAllProducts() throws Exception {
        // Given
        ProductDTO product1 = ProductDTO.builder()
                .id(1L)
                .name("Laptop")
                .price(BigDecimal.valueOf(999.99))
                .stockQuantity(10)
                .category("Electronics")
                .build();

        ProductDTO product2 = ProductDTO.builder()
                .id(2L)
                .name("Smartphone")
                .price(BigDecimal.valueOf(499.99))
                .stockQuantity(15)
                .category("Electronics")
                .build();

        Page<ProductDTO> productPage = new PageImpl<>(List.of(product1, product2), PageRequest.of(0, 10), 2);

        when(productService.getAllProducts(any(PageRequest.class))).thenReturn(productPage);

        // When & Then
        mockMvc.perform(get("/api/products")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.content").isArray())
                .andExpect(jsonPath("$.content.length()").value(2))
                .andExpect(jsonPath("$.content[0].name").value("Laptop"))
                .andExpect(jsonPath("$.content[1].name").value("Smartphone"));
    }

    @Test
    void shouldGetProductById() throws Exception {
        // Given
        ProductDTO product = ProductDTO.builder()
                .id(1L)
                .name("Laptop")
                .price(BigDecimal.valueOf(999.99))
                .stockQuantity(10)
                .category("Electronics")
                .build();

        when(productService.getProductById(1L)).thenReturn(product);

        // When & Then
        mockMvc.perform(get("/api/products/1")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value(1))
                .andExpect(jsonPath("$.name").value("Laptop"))
                .andExpect(jsonPath("$.price").value(999.99));
    }

    @Test
    void shouldSearchProducts() throws Exception {
        // Given
        ProductDTO product = ProductDTO.builder()
                .id(1L)
                .name("Laptop")
                .price(BigDecimal.valueOf(999.99))
                .stockQuantity(10)
                .category("Electronics")
                .build();

        Page<ProductDTO> productPage = new PageImpl<>(List.of(product), PageRequest.of(0, 10), 1);

        when(productService.searchProducts(eq("laptop"), any(PageRequest.class))).thenReturn(productPage);

        // When & Then
        mockMvc.perform(get("/api/products/search")
                        .param("name", "laptop")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.content[0].name").value("Laptop"));
    }

    @Test
    void shouldGetProductsByCategory() throws Exception {
        // Given
        ProductDTO product = ProductDTO.builder()
                .id(1L)
                .name("Laptop")
                .price(BigDecimal.valueOf(999.99))
                .stockQuantity(10)
                .category("Electronics")
                .build();

        Page<ProductDTO> productPage = new PageImpl<>(List.of(product), PageRequest.of(0, 10), 1);

        when(productService.getProductsByCategory(eq("Electronics"), any(PageRequest.class))).thenReturn(productPage);

        // When & Then
        mockMvc.perform(get("/api/products/category/Electronics")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.content[0].category").value("Electronics"));
    }

    @Test
    void shouldReturnNotFoundForNonExistentProduct() throws Exception {
        // Given
        when(productService.getProductById(999L)).thenThrow(
                new com.ecommerce.onlinestore.model.exception.ProductNotFoundException(999L));

        // When & Then
        mockMvc.perform(get("/api/products/999")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isNotFound());
    }
}

package com.ecommerce.onlinestore.integration;

import com.ecommerce.onlinestore.model.entity.Cart;
import com.ecommerce.onlinestore.model.entity.Product;
import com.ecommerce.onlinestore.repository.CartRepository;
import com.ecommerce.onlinestore.repository.ProductRepository;
import com.ecommerce.onlinestore.util.JsonUtils;
import com.ecommerce.onlinestore.util.TestDataFactory;
import com.ecommerce.onlinestore.util.TestConstants;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

import static org.hamcrest.Matchers.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest
@AutoConfigureMockMvc
@ContextConfiguration(classes = TestContainersConfig.class)
@Transactional
class CartIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private CartRepository cartRepository;

    @Autowired
    private ProductRepository productRepository;

    private List<Product> sampleProducts;
    private Cart testCart;

    @BeforeEach
    void setUp() {
        cartRepository.deleteAll();
        productRepository.deleteAll();

        sampleProducts = TestDataFactory.createSampleProducts();
        productRepository.saveAll(sampleProducts);

        testCart = TestDataFactory.createCart(null, TestConstants.TEST_SESSION_ID);
        cartRepository.save(testCart);
    }

    @Test
    void shouldCreateCart() throws Exception {
        mockMvc.perform(post("/api/carts")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.sessionId", notNullValue()))
                .andExpect(jsonPath("$.items", empty()));
    }

    @Test
    void shouldGetCartById() throws Exception {
        mockMvc.perform(get("/api/carts/{cartId}", testCart.getId())
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id", is(testCart.getId().intValue())))
                .andExpect(jsonPath("$.sessionId", is(TestConstants.TEST_SESSION_ID)));
    }

    @Test
    void shouldAddItemToCart() throws Exception {
        Product product = sampleProducts.get(0);
        String addItemRequest = JsonUtils.toJson(TestDataFactory.createAddToCartRequest(product.getId(), 2));

        mockMvc.perform(post("/api/carts/{cartId}/items", testCart.getId())
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(addItemRequest))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.items", hasSize(1)))
                .andExpect(jsonPath("$.items[0].productId", is(product.getId().intValue())))
                .andExpect(jsonPath("$.items[0].quantity", is(2)))
                .andExpect(jsonPath("$.totalItems", is(2)))
                .andExpect(jsonPath("$.totalPrice", is(1999.98))); // 999.99 * 2
    }

    @Test
    void shouldNotAddItemWithInsufficientStock() throws Exception {
        Product product = sampleProducts.get(0);
        // Try to add more than available stock
        String addItemRequest = JsonUtils.toJson(TestDataFactory.createAddToCartRequest(product.getId(), 20));

        mockMvc.perform(post("/api/carts/{cartId}/items", testCart.getId())
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(addItemRequest))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message", containsString("Insufficient stock")));
    }

    @Test
    void shouldUpdateCartItemQuantity() throws Exception {
        // First add an item
        Product product = sampleProducts.get(0);
        String addItemRequest = JsonUtils.toJson(TestDataFactory.createAddToCartRequest(product.getId(), 2));

        var result = mockMvc.perform(post("/api/carts/{cartId}/items", testCart.getId())
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(addItemRequest))
                .andReturn();

        // Extract item ID from response
        String response = result.getResponse().getContentAsString();
        Integer itemId = JsonUtils.fromJson(response, com.fasterxml.jackson.databind.JsonNode.class)
                .path("items").get(0).path("id").asInt();

        // Update quantity
        String updateRequest = "{\"quantity\": 5}";

        mockMvc.perform(put("/api/carts/{cartId}/items/{itemId}", testCart.getId(), itemId)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(updateRequest))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.items[0].quantity", is(5)))
                .andExpect(jsonPath("$.totalItems", is(5)))
                .andExpect(jsonPath("$.totalPrice", is(4999.95))); // 999.99 * 5
    }

    @Test
    void shouldRemoveItemFromCart() throws Exception {
        // First add an item
        Product product = sampleProducts.get(0);
        String addItemRequest = JsonUtils.toJson(TestDataFactory.createAddToCartRequest(product.getId(), 2));

        var result = mockMvc.perform(post("/api/carts/{cartId}/items", testCart.getId())
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(addItemRequest))
                .andReturn();

        // Extract item ID from response
        String response = result.getResponse().getContentAsString();
        Integer itemId = JsonUtils.fromJson(response, com.fasterxml.jackson.databind.JsonNode.class)
                .path("items").get(0).path("id").asInt();

        // Remove the item
        mockMvc.perform(delete("/api/carts/{cartId}/items/{itemId}", testCart.getId(), itemId)
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.items", empty()))
                .andExpect(jsonPath("$.totalItems", is(0)))
                .andExpect(jsonPath("$.totalPrice", is(0.0)));
    }

    @Test
    void shouldClearCart() throws Exception {
        // First add some items
        Product product1 = sampleProducts.get(0);
        Product product2 = sampleProducts.get(1);

        String addItem1Request = JsonUtils.toJson(TestDataFactory.createAddToCartRequest(product1.getId(), 1));
        String addItem2Request = JsonUtils.toJson(TestDataFactory.createAddToCartRequest(product2.getId(), 1));

        mockMvc.perform(post("/api/carts/{cartId}/items", testCart.getId())
                .contentType(MediaType.APPLICATION_JSON)
                .content(addItem1Request));

        mockMvc.perform(post("/api/carts/{cartId}/items", testCart.getId())
                .contentType(MediaType.APPLICATION_JSON)
                .content(addItem2Request));

        // Clear cart
        mockMvc.perform(delete("/api/carts/{cartId}/clear", testCart.getId())
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk());

        // Verify cart is empty
        mockMvc.perform(get("/api/carts/{cartId}", testCart.getId())
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.items", empty()))
                .andExpect(jsonPath("$.totalItems", is(0)))
                .andExpect(jsonPath("$.totalPrice", is(0.0)));
    }
}

package com.ecommerce.onlinestore.integration;

import com.ecommerce.onlinestore.model.entity.Cart;
import com.ecommerce.onlinestore.model.entity.Product;
import com.ecommerce.onlinestore.repository.CartRepository;
import com.ecommerce.onlinestore.repository.ProductRepository;
import com.ecommerce.onlinestore.util.JsonUtils;
import com.ecommerce.onlinestore.util.TestDataFactory;
import com.ecommerce.onlinestore.util.TestConstants;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

import static org.hamcrest.Matchers.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest
@AutoConfigureMockMvc
@ContextConfiguration(classes = TestContainersConfig.class)
@Transactional
class FullOrderFlowIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private CartRepository cartRepository;

    @Autowired
    private ProductRepository productRepository;

    private List<Product> sampleProducts;
    private Cart testCart;

    @BeforeEach
    void setUp() {
        cartRepository.deleteAll();
        productRepository.deleteAll();

        sampleProducts = TestDataFactory.createSampleProducts();
        productRepository.saveAll(sampleProducts);

        testCart = TestDataFactory.createCart(null, TestConstants.TEST_SESSION_ID);
        cartRepository.save(testCart);
    }

    @Test
    void shouldCompleteFullOrderFlow() throws Exception {
        // 1. Add items to cart
        Product laptop = sampleProducts.get(0);
        Product smartphone = sampleProducts.get(1);

        String addLaptopRequest = JsonUtils.toJson(TestDataFactory.createAddToCartRequest(laptop.getId(), 1));
        String addPhoneRequest = JsonUtils.toJson(TestDataFactory.createAddToCartRequest(smartphone.getId(), 2));

        mockMvc.perform(post("/api/carts/{cartId}/items", testCart.getId())
                .contentType(MediaType.APPLICATION_JSON)
                .content(addLaptopRequest));

        mockMvc.perform(post("/api/carts/{cartId}/items", testCart.getId())
                .contentType(MediaType.APPLICATION_JSON)
                .content(addPhoneRequest));

        // Verify cart contents
        mockMvc.perform(get("/api/carts/{cartId}", testCart.getId())
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.items", hasSize(2)))
                .andExpect(jsonPath("$.totalItems", is(3)))
                .andExpect(jsonPath("$.totalPrice", is(1999.97))); // 999.99 + (499.99 * 2)

        // 2. Create order
        String createOrderRequest = JsonUtils.toJson(TestDataFactory.createCreateOrderRequest(testCart.getId()));

        var orderResult = mockMvc.perform(post("/api/orders")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(createOrderRequest))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.orderNumber", notNullValue()))
                .andExpect(jsonPath("$.status", is("PENDING")))
                .andExpect(jsonPath("$.totalAmount", is(1999.97)))
                .andExpect(jsonPath("$.orderItems", hasSize(2)))
                .andExpect(jsonPath("$.customerInfo.customerEmail", is(TestConstants.TEST_CUSTOMER_EMAIL)))
                .andReturn();

        // Extract order number
        String orderResponse = orderResult.getResponse().getContentAsString();
        String orderNumber = JsonUtils.fromJson(orderResponse, com.fasterxml.jackson.databind.JsonNode.class)
                .path("orderNumber").asText();

        // 3. Verify cart is cleared after order
        mockMvc.perform(get("/api/carts/{cartId}", testCart.getId())
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.items", empty()))
                .andExpect(jsonPath("$.totalItems", is(0)))
                .andExpect(jsonPath("$.totalPrice", is(0.0)));

        // 4. Verify product stock is updated
        mockMvc.perform(get("/api/products/{id}", laptop.getId())
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.stockQuantity", is(9))); // Was 10, ordered 1

        mockMvc.perform(get("/api/products/{id}", smartphone.getId())
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.stockQuantity", is(13))); // Was 15, ordered 2

        // 5. Get order by number
        mockMvc.perform(get("/api/orders/number/{orderNumber}", orderNumber)
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.orderNumber", is(orderNumber)))
                .andExpect(jsonPath("$.orderItems", hasSize(2)));

        // 6. Update order status
        mockMvc.perform(put("/api/orders/{orderId}/status", 1) // Assuming order ID is 1
                        .param("status", "CONFIRMED")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.status", is("CONFIRMED")));
    }

    @Test
    void shouldNotCreateOrderFromEmptyCart() throws Exception {
        String createOrderRequest = JsonUtils.toJson(TestDataFactory.createCreateOrderRequest(testCart.getId()));

        mockMvc.perform(post("/api/orders")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(createOrderRequest))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message", containsString("empty cart")));
    }

    @Test
    void shouldNotCreateOrderWithInsufficientStock() throws Exception {
        // Add more items than available stock
        Product laptop = sampleProducts.get(0);
        String addItemRequest = JsonUtils.toJson(TestDataFactory.createAddToCartRequest(laptop.getId(), 15));

        mockMvc.perform(post("/api/carts/{cartId}/items", testCart.getId())
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(addItemRequest))
                .andExpect(status().isBadRequest());

        // Try to create order anyway
        String createOrderRequest = JsonUtils.toJson(TestDataFactory.createCreateOrderRequest(testCart.getId()));

        mockMvc.perform(post("/api/orders")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(createOrderRequest))
                .andExpect(status().isBadRequest());
    }
}

package com.ecommerce.onlinestore.integration;

import com.ecommerce.onlinestore.model.entity.Cart;
import com.ecommerce.onlinestore.model.entity.Product;
import com.ecommerce.onlinestore.repository.CartRepository;
import com.ecommerce.onlinestore.repository.ProductRepository;
import com.ecommerce.onlinestore.util.JsonUtils;
import com.ecommerce.onlinestore.util.TestDataFactory;
import com.ecommerce.onlinestore.util.TestConstants;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

import static org.hamcrest.Matchers.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest
@AutoConfigureMockMvc
@ContextConfiguration(classes = TestContainersConfig.class)
@Transactional
class OrderIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private CartRepository cartRepository;

    @Autowired
    private ProductRepository productRepository;

    private List<Product> sampleProducts;
    private Cart testCart;

    @BeforeEach
    void setUp() {
        cartRepository.deleteAll();
        productRepository.deleteAll();

        sampleProducts = TestDataFactory.createSampleProducts();
        productRepository.saveAll(sampleProducts);

        testCart = TestDataFactory.createCart(null, TestConstants.TEST_SESSION_ID);
        cartRepository.save(testCart);
    }

    @Test
    void shouldCreateOrder() throws Exception {
        // Add items to cart first
        Product laptop = sampleProducts.get(0);
        Product smartphone = sampleProducts.get(1);

        String addLaptopRequest = JsonUtils.toJson(TestDataFactory.createAddToCartRequest(laptop.getId(), 1));
        String addPhoneRequest = JsonUtils.toJson(TestDataFactory.createAddToCartRequest(smartphone.getId(), 1));

        mockMvc.perform(post("/api/carts/{cartId}/items", testCart.getId())
                .contentType(MediaType.APPLICATION_JSON)
                .content(addLaptopRequest));

        mockMvc.perform(post("/api/carts/{cartId}/items", testCart.getId())
                .contentType(MediaType.APPLICATION_JSON)
                .content(addPhoneRequest));

        // Create order
        String createOrderRequest = JsonUtils.toJson(TestDataFactory.createCreateOrderRequest(testCart.getId()));

        mockMvc.perform(post("/api/orders")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(createOrderRequest))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.orderNumber", notNullValue()))
                .andExpect(jsonPath("$.status", is("PENDING")))
                .andExpect(jsonPath("$.totalAmount", is(1499.98))) // 999.99 + 499.99
                .andExpect(jsonPath("$.orderItems", hasSize(2)))
                .andExpect(jsonPath("$.customerInfo.customerEmail", is(TestConstants.TEST_CUSTOMER_EMAIL)))
                .andExpect(jsonPath("$.shippingAddress.city", is(TestConstants.TEST_CITY)));
    }

    @Test
    void shouldGetOrderByNumber() throws Exception {
        // First create an order
        Product product = sampleProducts.get(0);
        String addItemRequest = JsonUtils.toJson(TestDataFactory.createAddToCartRequest(product.getId(), 1));

        mockMvc.perform(post("/api/carts/{cartId}/items", testCart.getId())
                .contentType(MediaType.APPLICATION_JSON)
                .content(addItemRequest));

        String createOrderRequest = JsonUtils.toJson(TestDataFactory.createCreateOrderRequest(testCart.getId()));

        var result = mockMvc.perform(post("/api/orders")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(createOrderRequest))
                .andReturn();

        String orderResponse = result.getResponse().getContentAsString();
        String orderNumber = JsonUtils.fromJson(orderResponse, com.fasterxml.jackson.databind.JsonNode.class)
                .path("orderNumber").asText();

        // Get order by number
        mockMvc.perform(get("/api/orders/number/{orderNumber}", orderNumber)
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.orderNumber", is(orderNumber)))
                .andExpect(jsonPath("$.status", is("PENDING")));
    }

    @Test
    void shouldGetOrdersByStatus() throws Exception {
        // Create an order first
        Product product = sampleProducts.get(0);
        String addItemRequest = JsonUtils.toJson(TestDataFactory.createAddToCartRequest(product.getId(), 1));

        mockMvc.perform(post("/api/carts/{cartId}/items", testCart.getId())
                .contentType(MediaType.APPLICATION_JSON)
                .content(addItemRequest));

        String createOrderRequest = JsonUtils.toJson(TestDataFactory.createCreateOrderRequest(testCart.getId()));

        mockMvc.perform(post("/api/orders")
                .contentType(MediaType.APPLICATION_JSON)
                .content(createOrderRequest));

        // Get orders by status
        mockMvc.perform(get("/api/orders/status/PENDING")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.content", hasSize(1)))
                .andExpect(jsonPath("$.content[0].status", is("PENDING")));
    }

    @Test
    void shouldUpdateOrderStatus() throws Exception {
        // Create an order first
        Product product = sampleProducts.get(0);
        String addItemRequest = JsonUtils.toJson(TestDataFactory.createAddToCartRequest(product.getId(), 1));

        mockMvc.perform(post("/api/carts/{cartId}/items", testCart.getId())
                .contentType(MediaType.APPLICATION_JSON)
                .content(addItemRequest));

        String createOrderRequest = JsonUtils.toJson(TestDataFactory.createCreateOrderRequest(testCart.getId()));

        var result = mockMvc.perform(post("/api/orders")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(createOrderRequest))
                .andReturn();

        String orderResponse = result.getResponse().getContentAsString();
        Long orderId = JsonUtils.fromJson(orderResponse, com.fasterxml.jackson.databind.JsonNode.class)
                .path("id").asLong();

        // Update order status
        mockMvc.perform(put("/api/orders/{orderId}/status", orderId)
                        .param("status", "CONFIRMED")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.status", is("CONFIRMED")));
    }

    @Test
    void shouldNotCreateOrderFromEmptyCart() throws Exception {
        String createOrderRequest = JsonUtils.toJson(TestDataFactory.createCreateOrderRequest(testCart.getId()));

        mockMvc.perform(post("/api/orders")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(createOrderRequest))
                .andExpect(status().isBadRequest());
    }
}

package com.ecommerce.onlinestore.integration;

import com.ecommerce.onlinestore.model.entity.Product;
import com.ecommerce.onlinestore.repository.ProductRepository;
import com.ecommerce.onlinestore.util.TestDataFactory;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.List;

import static org.hamcrest.Matchers.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest
@AutoConfigureMockMvc
@ContextConfiguration(classes = TestContainersConfig.class)
@Transactional
class ProductIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ProductRepository productRepository;

    private List<Product> sampleProducts;

    @BeforeEach
    void setUp() {
        productRepository.deleteAll();

        sampleProducts = TestDataFactory.createSampleProducts();
        productRepository.saveAll(sampleProducts);
    }

    @Test
    void shouldGetAllProducts() throws Exception {
        mockMvc.perform(get("/api/products")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.content", hasSize(4)))
                .andExpect(jsonPath("$.content[0].name", is("Laptop")))
                .andExpect(jsonPath("$.content[1].name", is("Smartphone")))
                .andExpect(jsonPath("$.content[2].name", is("Book")))
                .andExpect(jsonPath("$.content[3].name", is("Headphones")));
    }

    @Test
    void shouldGetProductById() throws Exception {
        Product product = sampleProducts.get(0);

        mockMvc.perform(get("/api/products/{id}", product.getId())
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id", is(product.getId().intValue())))
                .andExpect(jsonPath("$.name", is(product.getName())))
                .andExpect(jsonPath("$.price", is(product.getPrice().doubleValue())));
    }

    @Test
    void shouldReturnNotFoundForNonExistentProduct() throws Exception {
        mockMvc.perform(get("/api/products/999")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isNotFound());
    }

    @Test
    void shouldGetProductsByCategory() throws Exception {
        mockMvc.perform(get("/api/products/category/Electronics")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.content", hasSize(3)))
                .andExpect(jsonPath("$.content[*].category", everyItem(is("Electronics"))));
    }

    @Test
    void shouldSearchProducts() throws Exception {
        mockMvc.perform(get("/api/products/search")
                        .param("name", "laptop")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.content", hasSize(1)))
                .andExpect(jsonPath("$.content[0].name", is("Laptop")));
    }

    @Test
    void shouldFilterProductsByPriceRange() throws Exception {
        mockMvc.perform(get("/api/products/filter/price")
                        .param("minPrice", "100")
                        .param("maxPrice", "500")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.content", hasSize(2)))
                .andExpect(jsonPath("$.content[*].name", containsInAnyOrder("Smartphone", "Headphones")));
    }

    @Test
    void shouldGetAvailableProducts() throws Exception {
        // Create a product with zero stock
        Product outOfStockProduct = TestDataFactory.createProduct(
                5L, "Out of Stock Item", "Electronics", BigDecimal.valueOf(199.99), 0);
        productRepository.save(outOfStockProduct);

        mockMvc.perform(get("/api/products/available")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.content", hasSize(4))) // Only the original 4 products
                .andExpect(jsonPath("$.content[*].stockQuantity", everyItem(greaterThan(0))));
    }
}

package com.ecommerce.onlinestore.integration;

import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.MySQLContainer;
import org.testcontainers.junit.jupiter.Container;

@TestConfiguration
public class TestContainersConfig {

    @Container
    static MySQLContainer<?> mysql = new MySQLContainer<>("mysql:8.0")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");

    static {
        mysql.start();
    }

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", mysql::getJdbcUrl);
        registry.add("spring.datasource.username", mysql::getUsername);
        registry.add("spring.datasource.password", mysql::getPassword);
        registry.add("spring.jpa.hibernate.ddl-auto", () -> "create-drop");
    }
}

package com.ecommerce.onlinestore.repository;

import com.ecommerce.onlinestore.model.entity.Cart;
import com.ecommerce.onlinestore.util.TestConstants;
import com.ecommerce.onlinestore.util.TestDataFactory;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.context.annotation.Import;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.MySQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;

@DataJpaTest
@Testcontainers
@Import(TestDatabaseConfig.class)
class CartRepositoryTest {

    @Container
    static MySQLContainer<?> mysql = new MySQLContainer<>("mysql:8.0")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", mysql::getJdbcUrl);
        registry.add("spring.datasource.username", mysql::getUsername);
        registry.add("spring.datasource.password", mysql::getPassword);
    }

    @Autowired
    private CartRepository cartRepository;

    private Cart testCart;

    @BeforeEach
    void setUp() {
        cartRepository.deleteAll();

        testCart = TestDataFactory.createCart(1L, TestConstants.TEST_SESSION_ID);
        cartRepository.save(testCart);
    }

    @Test
    void shouldFindCartBySessionId() {
        Optional<Cart> found = cartRepository.findBySessionId(TestConstants.TEST_SESSION_ID);

        assertThat(found).isPresent();
        assertThat(found.get().getSessionId()).isEqualTo(TestConstants.TEST_SESSION_ID);
    }

    @Test
    void shouldFindCartByIdWithItems() {
        Optional<Cart> found = cartRepository.findByIdWithItems(testCart.getId());

        assertThat(found).isPresent();
        assertThat(found.get().getId()).isEqualTo(testCart.getId());
    }

    @Test
    void shouldReturnEmptyWhenCartNotFound() {
        Optional<Cart> found = cartRepository.findBySessionId("non-existent-session");

        assertThat(found).isEmpty();
    }

    @Test
    void shouldDeleteOldCarts() {
        // This test would require setting up carts with specific dates
        // For now, we just verify the method exists and can be called
        cartRepository.deleteOldCarts(java.time.LocalDateTime.now().minusDays(30));

        // Verify no exception is thrown
        assertThat(cartRepository.count()).isEqualTo(1);
    }
}

package com.ecommerce.onlinestore.repository;

import com.ecommerce.onlinestore.model.entity.Order;
import com.ecommerce.onlinestore.model.enums.OrderStatus;
import com.ecommerce.onlinestore.util.TestDataFactory;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.context.annotation.Import;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.MySQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.util.List;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;

@DataJpaTest
@Testcontainers
@Import(TestDatabaseConfig.class)
class OrderRepositoryTest {

    @Container
    static MySQLContainer<?> mysql = new MySQLContainer<>("mysql:8.0")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", mysql::getJdbcUrl);
        registry.add("spring.datasource.username", mysql::getUsername);
        registry.add("spring.datasource.password", mysql::getPassword);
    }

    @Autowired
    private OrderRepository orderRepository;

    private Order testOrder;

    @BeforeEach
    void setUp() {
        orderRepository.deleteAll();

        testOrder = TestDataFactory.createOrder(1L, "ORD-123", OrderStatus.PENDING);
        orderRepository.save(testOrder);
    }

    @Test
    void shouldFindOrderByOrderNumber() {
        Optional<Order> found = orderRepository.findByOrderNumber("ORD-123");

        assertThat(found).isPresent();
        assertThat(found.get().getOrderNumber()).isEqualTo("ORD-123");
    }

    @Test
    void shouldFindOrdersByStatus() {
        Pageable pageable = PageRequest.of(0, 10);
        Page<Order> orders = orderRepository.findByStatus(OrderStatus.PENDING, pageable);

        assertThat(orders.getContent()).hasSize(1);
        assertThat(orders.getContent().get(0).getStatus()).isEqualTo(OrderStatus.PENDING);
    }

    @Test
    void shouldFindOrdersByCustomerEmail() {
        Pageable pageable = PageRequest.of(0, 10);
        Page<Order> orders = orderRepository.findByCustomerInfo_CustomerEmail(
                "test@example.com", pageable);

        assertThat(orders.getContent()).hasSize(1);
        assertThat(orders.getContent().get(0).getCustomerInfo().getCustomerEmail())
                .isEqualTo("test@example.com");
    }

    @Test
    void shouldFindOrderByIdWithItems() {
        Optional<Order> found = orderRepository.findByIdWithItems(testOrder.getId());

        assertThat(found).isPresent();
        assertThat(found.get().getId()).isEqualTo(testOrder.getId());
    }

    @Test
    void shouldCountOrdersByStatus() {
        Long count = orderRepository.countByStatus(OrderStatus.PENDING);

        assertThat(count).isEqualTo(1);
    }

    @Test
    void shouldFindOrdersByStatusIn() {
        List<Order> orders = orderRepository.findByStatusIn(List.of(OrderStatus.PENDING, OrderStatus.CONFIRMED));

        assertThat(orders).hasSize(1);
        assertThat(orders.get(0).getStatus()).isEqualTo(OrderStatus.PENDING);
    }
}

package com.ecommerce.onlinestore.repository;

import com.ecommerce.onlinestore.model.entity.Product;
import com.ecommerce.onlinestore.util.TestDataFactory;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;

@DataJpaTest
class ProductRepositoryTest {

    @Autowired
    private ProductRepository productRepository;

    private List<Product> sampleProducts;

    @BeforeEach
    void setUp() {
        productRepository.deleteAll();

        sampleProducts = TestDataFactory.createSampleProducts();
        productRepository.saveAll(sampleProducts);
    }

    @Test
    void shouldFindAllProducts() {
        Pageable pageable = PageRequest.of(0, 10);
        Page<Product> products = productRepository.findAll(pageable);

        assertThat(products.getContent()).hasSize(4);
    }

    @Test
    void shouldFindProductsByCategory() {
        Pageable pageable = PageRequest.of(0, 10);
        Page<Product> electronics = productRepository.findByCategory("Electronics", pageable);

        assertThat(electronics.getContent()).hasSize(3);
        assertThat(electronics.getContent())
                .extracting(Product::getCategory)
                .containsOnly("Electronics");
    }

    @Test
    void shouldFindProductsByNameContaining() {
        Pageable pageable = PageRequest.of(0, 10);
        Page<Product> products = productRepository.findByNameContainingIgnoreCase("laptop", pageable);

        assertThat(products.getContent()).hasSize(1);
        assertThat(products.getContent().get(0).getName()).isEqualTo("Laptop");
    }

    @Test
    void shouldFindProductsByPriceRange() {
        Pageable pageable = PageRequest.of(0, 10);
        Page<Product> products = productRepository.findByPriceBetween(
                BigDecimal.valueOf(100), BigDecimal.valueOf(500), pageable);

        assertThat(products.getContent()).hasSize(2); // Smartphone and Headphones
    }

    @Test
    void shouldFindAvailableProducts() {
        Pageable pageable = PageRequest.of(0, 10);
        Page<Product> products = productRepository.findAvailableProducts(pageable);

        assertThat(products.getContent()).hasSize(4);
        assertThat(products.getContent())
                .allMatch(product -> product.getStockQuantity() > 0);
    }

    @Test
    void shouldFindProductBySku() {
        Product laptop = sampleProducts.get(0);
        Optional<Product> found = productRepository.findBySku(laptop.getSku());

        assertThat(found).isPresent();
        assertThat(found.get().getName()).isEqualTo("Laptop");
    }

    @Test
    void shouldSearchByKeyword() {
        Pageable pageable = PageRequest.of(0, 10);
        Page<Product> products = productRepository.searchByKeyword("phone", pageable);

        assertThat(products.getContent()).hasSize(1);
        assertThat(products.getContent().get(0).getName()).isEqualTo("Smartphone");
    }

    @Test
    void shouldFindProductsWithSufficientStock() {
        List<Product> products = productRepository.findByStockQuantityGreaterThan(10);

        assertThat(products).hasSize(3); // All except Laptop (stock 10)
        assertThat(products)
                .allMatch(product -> product.getStockQuantity() > 10);
    }
}

package com.ecommerce.onlinestore.repository;

import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@TestConfiguration
@EnableJpaAuditing
public class TestDatabaseConfig {
    // Configuration for test database
}

package com.ecommerce.onlinestore.service.impl;

import com.ecommerce.onlinestore.mapper.CartMapper;
import com.ecommerce.onlinestore.model.dto.AddToCartRequest;
import com.ecommerce.onlinestore.model.dto.CartDTO;
import com.ecommerce.onlinestore.model.entity.Cart;
import com.ecommerce.onlinestore.model.entity.Product;
import com.ecommerce.onlinestore.model.exception.CartNotFoundException;
import com.ecommerce.onlinestore.model.exception.InsufficientStockException;
import com.ecommerce.onlinestore.model.exception.ProductNotFoundException;
import com.ecommerce.onlinestore.repository.CartRepository;
import com.ecommerce.onlinestore.repository.ProductRepository;
import com.ecommerce.onlinestore.util.TestConstants;
import com.ecommerce.onlinestore.util.TestDataFactory;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.math.BigDecimal;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class CartServiceImplTest {

    @Mock
    private CartRepository cartRepository;

    @Mock
    private ProductRepository productRepository;

    @Mock
    private CartMapper cartMapper;

    @InjectMocks
    private CartServiceImpl cartService;

    private Cart testCart;
    private Product testProduct;
    private CartDTO testCartDTO;

    @BeforeEach
    void setUp() {
        testCart = TestDataFactory.createCart(1L, TestConstants.TEST_SESSION_ID);
        testProduct = TestDataFactory.createProduct(1L, "Laptop", "Electronics", BigDecimal.valueOf(999.99), 10);
        testCartDTO = new CartDTO();
    }

    @Test
    void shouldCreateCart() {
        when(cartRepository.save(any(Cart.class))).thenReturn(testCart);
        when(cartMapper.toDTO(testCart)).thenReturn(testCartDTO);

        CartDTO result = cartService.createCart(TestConstants.TEST_SESSION_ID);

        assertThat(result).isNotNull();
        verify(cartRepository).save(any(Cart.class));
    }

    @Test
    void shouldGetCartById() {
        when(cartRepository.findByIdWithItems(1L)).thenReturn(Optional.of(testCart));
        when(cartMapper.toDTO(testCart)).thenReturn(testCartDTO);

        CartDTO result = cartService.getCartById(1L);

        assertThat(result).isNotNull();
        verify(cartRepository).findByIdWithItems(1L);
    }

    @Test
    void shouldThrowExceptionWhenCartNotFound() {
        when(cartRepository.findByIdWithItems(999L)).thenReturn(Optional.empty());

        assertThatThrownBy(() -> cartService.getCartById(999L))
                .isInstanceOf(CartNotFoundException.class)
                .hasMessageContaining("Cart not found with id: 999");
    }

    @Test
    void shouldAddItemToCart() {
        AddToCartRequest request = new AddToCartRequest(1L, 2);

        when(cartRepository.findByIdWithItems(1L)).thenReturn(Optional.of(testCart));
        when(productRepository.findById(1L)).thenReturn(Optional.of(testProduct));
        when(cartRepository.save(any(Cart.class))).thenReturn(testCart);
        when(cartMapper.toDTO(testCart)).thenReturn(testCartDTO);

        CartDTO result = cartService.addItemToCart(1L, request);

        assertThat(result).isNotNull();
        verify(cartRepository).findByIdWithItems(1L);
        verify(productRepository).findById(1L);
        verify(cartRepository).save(any(Cart.class));
    }

    @Test
    void shouldThrowExceptionWhenProductNotFound() {
        AddToCartRequest request = new AddToCartRequest(999L, 2);

        when(cartRepository.findByIdWithItems(1L)).thenReturn(Optional.of(testCart));
        when(productRepository.findById(999L)).thenReturn(Optional.empty());

        assertThatThrownBy(() -> cartService.addItemToCart(1L, request))
                .isInstanceOf(ProductNotFoundException.class)
                .hasMessageContaining("Product not found with id: 999");
    }

    @Test
    void shouldThrowExceptionWhenInsufficientStock() {
        AddToCartRequest request = new AddToCartRequest(1L, 15); // More than available stock

        when(cartRepository.findByIdWithItems(1L)).thenReturn(Optional.of(testCart));
        when(productRepository.findById(1L)).thenReturn(Optional.of(testProduct));

        assertThatThrownBy(() -> cartService.addItemToCart(1L, request))
                .isInstanceOf(InsufficientStockException.class)
                .hasMessageContaining("Insufficient stock");
    }

    @Test
    void shouldClearCart() {
        when(cartRepository.findByIdWithItems(1L)).thenReturn(Optional.of(testCart));
        when(cartRepository.save(any(Cart.class))).thenReturn(testCart);

        cartService.clearCart(1L);

        verify(cartRepository).findByIdWithItems(1L);
        verify(cartRepository).save(any(Cart.class));
    }
}

package com.ecommerce.onlinestore.service.impl;

import com.ecommerce.onlinestore.mapper.OrderMapper;
import com.ecommerce.onlinestore.model.dto.CreateOrderRequest;
import com.ecommerce.onlinestore.model.dto.OrderDTO;
import com.ecommerce.onlinestore.model.entity.Cart;
import com.ecommerce.onlinestore.model.entity.Product;
import com.ecommerce.onlinestore.model.enums.OrderStatus;
import com.ecommerce.onlinestore.model.exception.CartNotFoundException;
import com.ecommerce.onlinestore.repository.CartRepository;
import com.ecommerce.onlinestore.repository.OrderRepository;
import com.ecommerce.onlinestore.repository.ProductRepository;
import com.ecommerce.onlinestore.util.TestDataFactory;
import com.ecommerce.onlinestore.util.TestConstants;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.math.BigDecimal;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class OrderServiceImplTest {

    @Mock
    private OrderRepository orderRepository;

    @Mock
    private CartRepository cartRepository;

    @Mock
    private ProductRepository productRepository;

    @Mock
    private OrderMapper orderMapper;

    @InjectMocks
    private OrderServiceImpl orderService;

    @Test
    void shouldCreateOrder() {
        // Given
        Cart cart = TestDataFactory.createCart(1L, TestConstants.TEST_SESSION_ID);
        Product product = TestDataFactory.createProduct(1L, "Laptop", "Electronics", BigDecimal.valueOf(999.99), 10);

        // Add item to cart
        var cartItem = TestDataFactory.createCartItem(1L, cart, product, 2);
        cart.addItem(cartItem);

        CreateOrderRequest request = TestDataFactory.createCreateOrderRequest(1L);

        when(cartRepository.findByIdWithItems(1L)).thenReturn(Optional.of(cart));
        when(orderRepository.save(any())).thenAnswer(invocation -> invocation.getArgument(0));
        when(orderMapper.toDTO(any())).thenReturn(OrderDTO.builder()
                .id(1L)
                .orderNumber("ORD-123")
                .status(OrderStatus.PENDING)
                .totalAmount(BigDecimal.valueOf(1999.98))
                .build());

        // When
        OrderDTO result = orderService.createOrder(request);

        // Then
        assertThat(result).isNotNull();
        assertThat(result.getOrderNumber()).isEqualTo("ORD-123");
        verify(cartRepository).findByIdWithItems(1L);
        verify(orderRepository).save(any());
        verify(productRepository, times(1)).save(any(Product.class)); // Stock update
    }

    @Test
    void shouldThrowExceptionWhenCartNotFound() {
        // Given
        CreateOrderRequest request = TestDataFactory.createCreateOrderRequest(999L);

        when(cartRepository.findByIdWithItems(999L)).thenReturn(Optional.empty());

        // When & Then
        assertThatThrownBy(() -> orderService.createOrder(request))
                .isInstanceOf(CartNotFoundException.class)
                .hasMessageContaining("Cart not found with id: 999");
    }

    @Test
    void shouldThrowExceptionWhenCartIsEmpty() {
        // Given
        Cart emptyCart = TestDataFactory.createCart(1L, TestConstants.TEST_SESSION_ID);
        CreateOrderRequest request = TestDataFactory.createCreateOrderRequest(1L);

        when(cartRepository.findByIdWithItems(1L)).thenReturn(Optional.of(emptyCart));

        // When & Then
        assertThatThrownBy(() -> orderService.createOrder(request))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("empty cart");
    }
}

package com.ecommerce.onlinestore.service.impl;

import com.ecommerce.onlinestore.mapper.ProductMapper;
import com.ecommerce.onlinestore.model.dto.ProductDTO;
import com.ecommerce.onlinestore.model.entity.Product;
import com.ecommerce.onlinestore.model.exception.ProductNotFoundException;
import com.ecommerce.onlinestore.repository.ProductRepository;
import com.ecommerce.onlinestore.util.TestDataFactory;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class ProductServiceImplTest {

    @Mock
    private ProductRepository productRepository;

    @Mock
    private ProductMapper productMapper;

    @InjectMocks
    private ProductServiceImpl productService;

    private Product testProduct;
    private ProductDTO testProductDTO;
    private List<Product> sampleProducts;

    @BeforeEach
    void setUp() {
        testProduct = TestDataFactory.createProduct(1L, "Laptop", "Electronics", BigDecimal.valueOf(999.99), 10);
        testProductDTO = TestDataFactory.createProductDTO(1L, "Laptop", "Electronics", BigDecimal.valueOf(999.99), 10);
        sampleProducts = TestDataFactory.createSampleProducts();
    }

    @Test
    void shouldGetProductById() {
        when(productRepository.findById(1L)).thenReturn(Optional.of(testProduct));
        when(productMapper.toDTO(testProduct)).thenReturn(testProductDTO);

        ProductDTO result = productService.getProductById(1L);

        assertThat(result).isNotNull();
        assertThat(result.getId()).isEqualTo(1L);
        assertThat(result.getName()).isEqualTo("Laptop");
        verify(productRepository).findById(1L);
    }

    @Test
    void shouldThrowExceptionWhenProductNotFound() {
        when(productRepository.findById(999L)).thenReturn(Optional.empty());

        assertThatThrownBy(() -> productService.getProductById(999L))
                .isInstanceOf(ProductNotFoundException.class)
                .hasMessageContaining("Product not found with id: 999");
    }

    @Test
    void shouldGetAllProducts() {
        Pageable pageable = PageRequest.of(0, 10);
        Page<Product> productPage = new PageImpl<>(sampleProducts, pageable, sampleProducts.size());

        when(productRepository.findAll(pageable)).thenReturn(productPage);
        when(productMapper.toDTO(any(Product.class))).thenReturn(testProductDTO);

        Page<ProductDTO> result = productService.getAllProducts(pageable);

        assertThat(result).isNotNull();
        assertThat(result.getContent()).hasSize(4);
        verify(productRepository).findAll(pageable);
    }

    @Test
    void shouldGetProductsByCategory() {
        Pageable pageable = PageRequest.of(0, 10);
        List<Product> electronics = sampleProducts.stream()
                .filter(p -> "Electronics".equals(p.getCategory()))
                .toList();
        Page<Product> productPage = new PageImpl<>(electronics, pageable, electronics.size());

        when(productRepository.findByCategory("Electronics", pageable)).thenReturn(productPage);
        when(productMapper.toDTO(any(Product.class))).thenReturn(testProductDTO);

        Page<ProductDTO> result = productService.getProductsByCategory("Electronics", pageable);

        assertThat(result).isNotNull();
        assertThat(result.getContent()).hasSize(3);
        verify(productRepository).findByCategory("Electronics", pageable);
    }

    @Test
    void shouldSearchProducts() {
        Pageable pageable = PageRequest.of(0, 10);
        List<Product> searchResults = List.of(testProduct);
        Page<Product> productPage = new PageImpl<>(searchResults, pageable, searchResults.size());

        when(productRepository.findByNameContainingIgnoreCase("laptop", pageable)).thenReturn(productPage);
        when(productMapper.toDTO(any(Product.class))).thenReturn(testProductDTO);

        Page<ProductDTO> result = productService.searchProducts("laptop", pageable);

        assertThat(result).isNotNull();
        assertThat(result.getContent()).hasSize(1);
        verify(productRepository).findByNameContainingIgnoreCase("laptop", pageable);
    }

    @Test
    void shouldGetProductBySku() {
        when(productRepository.findBySku("SKU-Laptop")).thenReturn(Optional.of(testProduct));
        when(productMapper.toDTO(testProduct)).thenReturn(testProductDTO);

        ProductDTO result = productService.getProductBySku("SKU-Laptop");

        assertThat(result).isNotNull();
        assertThat(result.getSku()).isEqualTo("SKU-Laptop");
        verify(productRepository).findBySku("SKU-Laptop");
    }
}

package com.ecommerce.onlinestore.service;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class CartServiceTest {

    @Test
    void shouldGetCartById() {
        // This is now a unit test without Spring context
        assertTrue(true);
    }

    @Test
    void shouldGetCartBySessionId() {
        assertTrue(true);
    }

    private void assertTrue(boolean condition) {
        if (!condition) {
            throw new AssertionError("Expected true");
        }
    }
}

package com.ecommerce.onlinestore.service;

import com.ecommerce.onlinestore.model.dto.CreateOrderRequest;
import com.ecommerce.onlinestore.model.dto.OrderDTO;
import com.ecommerce.onlinestore.model.enums.OrderStatus;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;

import java.math.BigDecimal;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@SpringBootTest
class OrderServiceTest {

    @MockBean
    private OrderService orderService;

    @Test
    void shouldCreateOrder() {
        // Given
        CreateOrderRequest request = new CreateOrderRequest();
        OrderDTO orderDTO = OrderDTO.builder()
                .id(1L)
                .orderNumber("ORD-123")
                .status(OrderStatus.PENDING)
                .totalAmount(BigDecimal.valueOf(999.99))
                .build();

        when(orderService.createOrder(any(CreateOrderRequest.class))).thenReturn(orderDTO);

        // Test implementation would verify the service behavior
    }
}

package com.ecommerce.onlinestore.service;

import com.ecommerce.onlinestore.model.dto.ProductDTO;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;

import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.Mockito.when;

@SpringBootTest
class ProductServiceTest {

    @MockBean
    private ProductService productService;

    @Test
    void shouldGetProductById() {
        // Given
        ProductDTO productDTO = new ProductDTO();
        when(productService.getProductById(anyLong())).thenReturn(productDTO);

        // Test implementation would verify the service behavior
    }
}

package com.ecommerce.onlinestore.util;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public class JsonUtils {

    private static final ObjectMapper objectMapper = new ObjectMapper();

    public static String toJson(Object object) {
        try {
            return objectMapper.writeValueAsString(object);
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Failed to convert object to JSON", e);
        }
    }

    public static <T> T fromJson(String json, Class<T> clazz) {
        try {
            return objectMapper.readValue(json, clazz);
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Failed to convert JSON to object", e);
        }
    }
}

package com.ecommerce.onlinestore.util;

public class TestConstants {

    public static final String TEST_SESSION_ID = "test-session-123";
    public static final String TEST_CUSTOMER_EMAIL = "test@example.com";
    public static final String TEST_CUSTOMER_NAME = "Test User";
    public static final String TEST_CUSTOMER_PHONE = "+1234567890";

    public static final String TEST_STREET = "123 Test St";
    public static final String TEST_CITY = "Test City";
    public static final String TEST_STATE = "Test State";
    public static final String TEST_POSTAL_CODE = "12345";
    public static final String TEST_COUNTRY = "Test Country";

    private TestConstants() {
        // Utility class
    }
}

package com.ecommerce.onlinestore.util;

import com.ecommerce.onlinestore.model.dto.*;
import com.ecommerce.onlinestore.model.entity.*;
import com.ecommerce.onlinestore.model.enums.OrderStatus;

import java.math.BigDecimal;
import java.util.List;

public class TestDataFactory {

    public static Product createProduct(Long id, String name, String category, BigDecimal price, Integer stock) {
        return Product.builder()
                .id(id)
                .name(name)
                .description("Test description for " + name)
                .price(price)
                .stockQuantity(stock)
                .category(category)
                .sku("SKU-" + name)
                .build();
    }

    public static ProductDTO createProductDTO(Long id, String name, String category, BigDecimal price, Integer stock) {
        return ProductDTO.builder()
                .id(id)
                .name(name)
                .description("Test description for " + name)
                .price(price)
                .stockQuantity(stock)
                .category(category)
                .sku("SKU-" + name)
                .build();
    }

    public static Cart createCart(Long id, String sessionId) {
        return Cart.builder()
                .id(id)
                .sessionId(sessionId)
                .totalPrice(BigDecimal.ZERO)
                .totalItems(0)
                .build();
    }

    public static CartItem createCartItem(Long id, Cart cart, Product product, Integer quantity) {
        return CartItem.builder()
                .id(id)
                .cart(cart)
                .product(product)
                .quantity(quantity)
                .unitPrice(product.getPrice())
                .build();
    }

    public static Order createOrder(Long id, String orderNumber, OrderStatus status) {
        return Order.builder()
                .id(id)
                .orderNumber(orderNumber)
                .status(status)
                .totalAmount(BigDecimal.valueOf(199.98))
                .customerInfo(createCustomerInfo())
                .shippingAddress(createAddress())
                .build();
    }

    public static CustomerInfo createCustomerInfo() {
        return CustomerInfo.builder()
                .customerName(TestConstants.TEST_CUSTOMER_NAME)
                .customerEmail(TestConstants.TEST_CUSTOMER_EMAIL)
                .customerPhone(TestConstants.TEST_CUSTOMER_PHONE)
                .build();
    }

    public static Address createAddress() {
        return Address.builder()
                .street(TestConstants.TEST_STREET)
                .city(TestConstants.TEST_CITY)
                .state(TestConstants.TEST_STATE)
                .postalCode(TestConstants.TEST_POSTAL_CODE)
                .country(TestConstants.TEST_COUNTRY)
                .build();
    }

    public static CustomerInfoDTO createCustomerInfoDTO() {
        return CustomerInfoDTO.builder()
                .customerName(TestConstants.TEST_CUSTOMER_NAME)
                .customerEmail(TestConstants.TEST_CUSTOMER_EMAIL)
                .customerPhone(TestConstants.TEST_CUSTOMER_PHONE)
                .build();
    }

    public static AddressDTO createAddressDTO() {
        return AddressDTO.builder()
                .street(TestConstants.TEST_STREET)
                .city(TestConstants.TEST_CITY)
                .state(TestConstants.TEST_STATE)
                .postalCode(TestConstants.TEST_POSTAL_CODE)
                .country(TestConstants.TEST_COUNTRY)
                .build();
    }

    public static CreateOrderRequest createCreateOrderRequest(Long cartId) {
        return new CreateOrderRequest(
                cartId,
                createCustomerInfoDTO(),
                createAddressDTO()
        );
    }

    public static AddToCartRequest createAddToCartRequest(Long productId, Integer quantity) {
        return new AddToCartRequest(productId, quantity);
    }

    public static List<Product> createSampleProducts() {
        return List.of(
                createProduct(1L, "Laptop", "Electronics", BigDecimal.valueOf(999.99), 10),
                createProduct(2L, "Smartphone", "Electronics", BigDecimal.valueOf(499.99), 15),
                createProduct(3L, "Book", "Books", BigDecimal.valueOf(29.99), 50),
                createProduct(4L, "Headphones", "Electronics", BigDecimal.valueOf(149.99), 20)
        );
    }
}

package com.ecommerce.onlinestore;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;

import static org.junit.jupiter.api.Assertions.assertTrue;

@SpringBootTest
@ActiveProfiles("test")
class OnlineStoreApplicationTests {

    @Test
    void contextLoads() {
        // Context should load without exceptions
        assertTrue(true);
    }
}

# Compiled class file
*.class

# Log file
*.log

# BlueJ files
*.ctxt

# Mobile Tools for Java (J2ME)
.mtj.tmp/

# Package Files #
*.jar
*.war
*.nar
*.ear
*.zip
*.tar.gz
*.rar

# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml
hs_err_pid*

# Maven
target/
pom.xml.tag
pom.xml.releaseBackup
pom.xml.versionsBackup
pom.xml.next
release.properties
dependency-reduced-pom.xml
buildNumber.properties
.mvn/timing.properties
.mvn/wrapper/maven-wrapper.jar

# IDE
.idea/
*.iws
*.iml
*.ipr
.classpath
.project
.settings/
bin/
*.tmp
*.bak
*.swp
*~.nib
local.properties
.loadpath

# Eclipse
.vscode/

# Mac
.DS_Store

# Windows
Thumbs.db

# Application
application-dev.yml
application-prod.yml

# Database
*.db

# Logs
logs/
*.log.*
!logs/.gitkeep

# Docker
docker-compose.override.yml

# Environment variables
.env

version: '3.8'

services:
  mysql:
    image: mysql:8.0
    container_name: ecommerce-mysql
    environment:
      MYSQL_ROOT_PASSWORD: password
      MYSQL_DATABASE: online_store
      MYSQL_USER: app_user
      MYSQL_PASSWORD: app_password
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
    command: --default-authentication-plugin=mysql_native_password

  app:
    build: .
    container_name: ecommerce-app
    environment:
      SPRING_DATASOURCE_URL: jdbc:mysql://mysql:3306/online_store?useSSL=false&serverTimezone=UTC
      SPRING_DATASOURCE_USERNAME: app_user
      SPRING_DATASOURCE_PASSWORD: app_password
    ports:
      - "8080:8080"
    depends_on:
      - mysql
    restart: unless-stopped

volumes:
  mysql_data:

FROM openjdk:21-jdk-slim

WORKDIR /app

COPY target/online-store-1.0.0.jar app.jar

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "app.jar"]

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>

    <groupId>com.ecommerce</groupId>
    <artifactId>online-store</artifactId>
    <version>1.0.0</version>
    <name>online-store</name>
    <description>E-commerce Backend Application</description>

    <properties>
        <java.version>21</java.version>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <mapstruct.version>1.5.5.Final</mapstruct.version>
        <testcontainers.version>1.19.3</testcontainers.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Utilities -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${mapstruct.version}</version>
        </dependency>

        <!-- Documentation -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>2.3.0</version>
        </dependency>

        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>${testcontainers.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>mysql</artifactId>
            <version>${testcontainers.version}</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>1.18.30</version>
                        </path>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${mapstruct.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

[ERROR] Failures: 
[ERROR]   ProductControllerTest.shouldReturnNotFoundForNonExistentProduct:141 Status expected:<404> but was:<400>
[ERROR]   ProductRepositoryTest.shouldSearchByKeyword:96 
Expected size: 1 but was: 2 in:
[com.ecommerce.onlinestore.model.entity.Product@7ba6e5e3,
    com.ecommerce.onlinestore.model.entity.Product@94170d6]
[ERROR] Errors: 
[ERROR]   CartIntegrationTest.shouldAddItemToCart � IllegalState ApplicationContext failure threshold (1) exceeded: skipping repeated attempt to load context for [WebMergedContextConfiguration@1802f60c testClass = com.ecommerce.onlinestore.integration.CartIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@3fcb737 key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   CartIntegrationTest.shouldClearCart � IllegalState ApplicationContext failure threshold (1) exceeded: skipping repeated attempt to load context for [WebMergedContextConfiguration@1802f60c testClass = com.ecommerce.onlinestore.integration.CartIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@3fcb737 key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   CartIntegrationTest.shouldCreateCart � IllegalState ApplicationContext failure threshold (1) exceeded: skipping repeated attempt to load context for [WebMergedContextConfiguration@1802f60c testClass = com.ecommerce.onlinestore.integration.CartIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@3fcb737 key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   CartIntegrationTest.shouldGetCartById � IllegalState Failed to load ApplicationContext for [WebMergedContextConfiguration@1802f60c testClass = com.ecommerce.onlinestore.integration.CartIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@3fcb737 key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   CartIntegrationTest.shouldNotAddItemWithInsufficientStock � IllegalState ApplicationContext failure threshold (1) exceeded: skipping repeated attempt to load context for [WebMergedContextConfiguration@1802f60c testClass = com.ecommerce.onlinestore.integration.CartIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@3fcb737 key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   CartIntegrationTest.shouldRemoveItemFromCart � IllegalState ApplicationContext failure threshold (1) exceeded: skipping repeated attempt to load context for [WebMergedContextConfiguration@1802f60c testClass = com.ecommerce.onlinestore.integration.CartIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@3fcb737 key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   CartIntegrationTest.shouldUpdateCartItemQuantity � IllegalState ApplicationContext failure threshold (1) exceeded: skipping repeated attempt to load context for [WebMergedContextConfiguration@1802f60c testClass = com.ecommerce.onlinestore.integration.CartIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@3fcb737 key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   FullOrderFlowIntegrationTest.shouldCompleteFullOrderFlow � IllegalState ApplicationContext failure threshold (1) exceeded: skipping repeated attempt to load context for [WebMergedContextConfiguration@726e29d testClass = com.ecommerce.onlinestore.integration.FullOrderFlowIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@a1e578f key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   FullOrderFlowIntegrationTest.shouldNotCreateOrderFromEmptyCart � IllegalState ApplicationContext failure threshold (1) exceeded: skipping repeated attempt to load context for [WebMergedContextConfiguration@726e29d testClass = com.ecommerce.onlinestore.integration.FullOrderFlowIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@a1e578f key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   FullOrderFlowIntegrationTest.shouldNotCreateOrderWithInsufficientStock � IllegalState ApplicationContext failure threshold (1) exceeded: skipping repeated attempt to load context for [WebMergedContextConfiguration@726e29d testClass = com.ecommerce.onlinestore.integration.FullOrderFlowIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@a1e578f key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   OrderIntegrationTest.shouldCreateOrder � IllegalState ApplicationContext failure threshold (1) exceeded: skipping repeated attempt to load context for [WebMergedContextConfiguration@6a30f6b1 testClass = com.ecommerce.onlinestore.integration.OrderIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@21f94fe3 key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   OrderIntegrationTest.shouldGetOrderByNumber � IllegalState ApplicationContext failure threshold (1) exceeded: skipping repeated attempt to load context for [WebMergedContextConfiguration@6a30f6b1 testClass = com.ecommerce.onlinestore.integration.OrderIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@21f94fe3 key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   OrderIntegrationTest.shouldGetOrdersByStatus � IllegalState ApplicationContext failure threshold (1) exceeded: skipping repeated attempt to load context for [WebMergedContextConfiguration@6a30f6b1 testClass = com.ecommerce.onlinestore.integration.OrderIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@21f94fe3 key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   OrderIntegrationTest.shouldNotCreateOrderFromEmptyCart � IllegalState ApplicationContext failure threshold (1) exceeded: skipping repeated attempt to load context for [WebMergedContextConfiguration@6a30f6b1 testClass = com.ecommerce.onlinestore.integration.OrderIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@21f94fe3 key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   OrderIntegrationTest.shouldUpdateOrderStatus � IllegalState ApplicationContext failure threshold (1) exceeded: skipping repeated attempt to load context for [WebMergedContextConfiguration@6a30f6b1 testClass = com.ecommerce.onlinestore.integration.OrderIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@21f94fe3 key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   ProductIntegrationTest.shouldFilterProductsByPriceRange � IllegalState ApplicationContext failure threshold (1) exceeded: skipping repeated attempt to load context for [WebMergedContextConfiguration@34588991 testClass = com.ecommerce.onlinestore.integration.ProductIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@3d01b609 key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   ProductIntegrationTest.shouldGetAllProducts � IllegalState ApplicationContext failure threshold (1) exceeded: skipping repeated attempt to load context for [WebMergedContextConfiguration@34588991 testClass = com.ecommerce.onlinestore.integration.ProductIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@3d01b609 key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   ProductIntegrationTest.shouldGetAvailableProducts � IllegalState ApplicationContext failure threshold (1) exceeded: skipping repeated attempt to load context for [WebMergedContextConfiguration@34588991 testClass = com.ecommerce.onlinestore.integration.ProductIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@3d01b609 key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   ProductIntegrationTest.shouldGetProductById � IllegalState ApplicationContext failure threshold (1) exceeded: skipping repeated attempt to load context for [WebMergedContextConfiguration@34588991 testClass = com.ecommerce.onlinestore.integration.ProductIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@3d01b609 key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   ProductIntegrationTest.shouldGetProductsByCategory � IllegalState ApplicationContext failure threshold (1) exceeded: skipping repeated attempt to load context for [WebMergedContextConfiguration@34588991 testClass = com.ecommerce.onlinestore.integration.ProductIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@3d01b609 key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   ProductIntegrationTest.shouldReturnNotFoundForNonExistentProduct � IllegalState ApplicationContext failure threshold (1) exceeded: skipping repeated attempt to load context for [WebMergedContextConfiguration@34588991 testClass = com.ecommerce.onlinestore.integration.ProductIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@3d01b609 key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   ProductIntegrationTest.shouldSearchProducts � IllegalState ApplicationContext failure threshold (1) exceeded: skipping repeated attempt to load context for [WebMergedContextConfiguration@34588991 testClass = com.ecommerce.onlinestore.integration.ProductIntegrationTest, locations = [], classes = [com.ecommerce.onlinestore.OnlineStoreApplication, com.ecommerce.onlinestore.integration.TestContainersConfig], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [[ImportsContextCustomizer@3d01b609 key = [org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration, org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityConfiguration, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration, org.springframework.boot.test.autoconfigure.web.reactive.WebTestClientAutoConfiguration]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@39ac0c0a, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@6d167f58, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@c697186, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@4b3fa0b3, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@42b02722, org.springframework.boot.test.context.SpringBootTestAnnotation@1b27dd90], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[ERROR]   CartRepositoryTest � IllegalState Previous attempts to find a Docker environment failed. Will not retry. Please see logs and check configuration
[ERROR]   OrderRepositoryTest � IllegalState Previous attempts to find a Docker environment failed. Will not retry. Please see logs and check configuration

всё проверь, всё исправь. если есть ошибки, файлы пререписывай полностью.